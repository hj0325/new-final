[{"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/_app.js":"1","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/index.jsx":"2","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v1/index.jsx":"3","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v2/index.jsx":"4","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v3/index.jsx":"5","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v4/index.jsx":"6","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker.jsx":"7","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Ax.jsx":"8","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Calumn.jsx":"9","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Scale.jsx":"10","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/Emoji3D.jsx":"11","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/EmojiSelector3D.jsx":"12","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/EmotionColumn.jsx":"13","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/FallingModels.jsx":"14","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/FullScreenContainer.jsx":"15","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/GameModal.jsx":"16","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/IconBarPlaceholder.jsx":"17","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/ScaledScene.jsx":"18","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/TextInputModal.jsx":"19","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/constants.js":"20","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/EmotionColumn.jsx":"21","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/FallingModels.jsx":"22","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/FullScreenContainer.jsx":"23","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/GameModal.jsx":"24","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/IconBarPlaceholder.jsx":"25","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/ScaledScene.jsx":"26","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/TextInputModal.jsx":"27","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/constants.js":"28","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/Emoji3D.jsx":"29","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/EmojiSelector3D.jsx":"30","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/EmotionColumn.jsx":"31","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/FallingModels.jsx":"32","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/FullScreenContainer.jsx":"33","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/GameModal.jsx":"34","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/IconBarPlaceholder.jsx":"35","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/ScaledScene.jsx":"36","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/TextInputModal.jsx":"37","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/constants.js":"38","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/BasketColliders.jsx":"39","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/Emoji3D.jsx":"40","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/EmojiSelector3D.jsx":"41","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/EmotionColumn.jsx":"42","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingEmoji3D.jsx":"43","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingEmojiManager.jsx":"44","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingModels.jsx":"45","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingSelectedEmojiScene.jsx":"46","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FullScreenContainer.jsx":"47","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/GameModal.jsx":"48","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/IconBarPlaceholder.jsx":"49","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaleEmoji3D.jsx":"50","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaleEmojis.jsx":"51","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaledScene.jsx":"52","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/TextInputModal.jsx":"53","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/constants.js":"54","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v5/index.jsx":"55","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/BasketEmoji3D.jsx":"56","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/BasketEmojiManager.jsx":"57","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/OverflowEmoji3D.jsx":"58","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/OverflowEmojiManager.jsx":"59","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/PhysicsGround.jsx":"60","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker-alt.js":"61"},{"size":781,"mtime":1748354603310,"results":"62","hashOfConfig":"63"},{"size":55,"mtime":1749777649595,"results":"64","hashOfConfig":"63"},{"size":8963,"mtime":1748532192768,"results":"65","hashOfConfig":"63"},{"size":8013,"mtime":1747358673885,"results":"66","hashOfConfig":"63"},{"size":8879,"mtime":1750142343292,"results":"67","hashOfConfig":"63"},{"size":23168,"mtime":1748960296225,"results":"68","hashOfConfig":"63"},{"size":32969,"mtime":1749284715539,"results":"69","hashOfConfig":"63"},{"size":1064,"mtime":1746673657548,"results":"70","hashOfConfig":"63"},{"size":326,"mtime":1746602390000,"results":"71","hashOfConfig":"63"},{"size":3882,"mtime":1748938018793,"results":"72","hashOfConfig":"63"},{"size":3293,"mtime":1748354057940,"results":"73","hashOfConfig":"63"},{"size":2744,"mtime":1748354057940,"results":"74","hashOfConfig":"63"},{"size":2815,"mtime":1747358323828,"results":"75","hashOfConfig":"63"},{"size":3256,"mtime":1747358323827,"results":"76","hashOfConfig":"63"},{"size":402,"mtime":1747358323850,"results":"77","hashOfConfig":"63"},{"size":3604,"mtime":1747358323834,"results":"78","hashOfConfig":"63"},{"size":725,"mtime":1747358323845,"results":"79","hashOfConfig":"63"},{"size":1032,"mtime":1747358323834,"results":"80","hashOfConfig":"63"},{"size":1760,"mtime":1747358323834,"results":"81","hashOfConfig":"63"},{"size":377,"mtime":1747358323850,"results":"82","hashOfConfig":"63"},{"size":2815,"mtime":1747358679320,"results":"83","hashOfConfig":"63"},{"size":3256,"mtime":1747358679321,"results":"84","hashOfConfig":"63"},{"size":402,"mtime":1747358679322,"results":"85","hashOfConfig":"63"},{"size":3604,"mtime":1747358679322,"results":"86","hashOfConfig":"63"},{"size":725,"mtime":1747358679323,"results":"87","hashOfConfig":"63"},{"size":1032,"mtime":1747358679323,"results":"88","hashOfConfig":"63"},{"size":1760,"mtime":1747358679323,"results":"89","hashOfConfig":"63"},{"size":377,"mtime":1747358679324,"results":"90","hashOfConfig":"63"},{"size":6109,"mtime":1747963086212,"results":"91","hashOfConfig":"63"},{"size":2484,"mtime":1747963086213,"results":"92","hashOfConfig":"63"},{"size":2815,"mtime":1747963086213,"results":"93","hashOfConfig":"63"},{"size":3256,"mtime":1747963086213,"results":"94","hashOfConfig":"63"},{"size":402,"mtime":1747963086214,"results":"95","hashOfConfig":"63"},{"size":3604,"mtime":1747963086214,"results":"96","hashOfConfig":"63"},{"size":725,"mtime":1747963086214,"results":"97","hashOfConfig":"63"},{"size":1032,"mtime":1747963086215,"results":"98","hashOfConfig":"63"},{"size":1760,"mtime":1747963086215,"results":"99","hashOfConfig":"63"},{"size":377,"mtime":1747963086215,"results":"100","hashOfConfig":"63"},{"size":3167,"mtime":1748571774337,"results":"101","hashOfConfig":"63"},{"size":2378,"mtime":1750142159549,"results":"102","hashOfConfig":"63"},{"size":2358,"mtime":1748354057962,"results":"103","hashOfConfig":"63"},{"size":7949,"mtime":1750158645729,"results":"104","hashOfConfig":"63"},{"size":5014,"mtime":1748938018908,"results":"105","hashOfConfig":"63"},{"size":6554,"mtime":1748938087073,"results":"106","hashOfConfig":"63"},{"size":4215,"mtime":1748534671367,"results":"107","hashOfConfig":"63"},{"size":4999,"mtime":1748534435180,"results":"108","hashOfConfig":"63"},{"size":859,"mtime":1750142292428,"results":"109","hashOfConfig":"63"},{"size":5993,"mtime":1749275220236,"results":"110","hashOfConfig":"63"},{"size":725,"mtime":1747963950343,"results":"111","hashOfConfig":"63"},{"size":1426,"mtime":1748357896690,"results":"112","hashOfConfig":"63"},{"size":3333,"mtime":1748357896690,"results":"113","hashOfConfig":"63"},{"size":1032,"mtime":1749366296899,"results":"114","hashOfConfig":"63"},{"size":2260,"mtime":1748947717115,"results":"115","hashOfConfig":"63"},{"size":377,"mtime":1747963950345,"results":"116","hashOfConfig":"63"},{"size":50756,"mtime":1750160372997,"results":"117","hashOfConfig":"63"},{"size":1791,"mtime":1749012162464,"results":"118","hashOfConfig":"63"},{"size":7081,"mtime":1749368422211,"results":"119","hashOfConfig":"63"},{"size":1778,"mtime":1749011298140,"results":"120","hashOfConfig":"63"},{"size":2964,"mtime":1749012184696,"results":"121","hashOfConfig":"63"},{"size":1373,"mtime":1749011067121,"results":"122","hashOfConfig":"63"},{"size":5728,"mtime":1746753395685,"results":"123","hashOfConfig":"63"},{"filePath":"124","messages":"125","suppressedMessages":"126","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"154jdlv",{"filePath":"127","messages":"128","suppressedMessages":"129","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"130","messages":"131","suppressedMessages":"132","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"133","messages":"134","suppressedMessages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136"},{"filePath":"137","messages":"138","suppressedMessages":"139","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"140","messages":"141","suppressedMessages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"143"},{"filePath":"144","messages":"145","suppressedMessages":"146","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"147"},{"filePath":"148","messages":"149","suppressedMessages":"150","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"151"},{"filePath":"152","messages":"153","suppressedMessages":"154","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"155"},{"filePath":"156","messages":"157","suppressedMessages":"158","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"159"},{"filePath":"160","messages":"161","suppressedMessages":"162","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"163"},{"filePath":"164","messages":"165","suppressedMessages":"166","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"167","messages":"168","suppressedMessages":"169","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"170"},{"filePath":"171","messages":"172","suppressedMessages":"173","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"174"},{"filePath":"175","messages":"176","suppressedMessages":"177","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"178","messages":"179","suppressedMessages":"180","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181"},{"filePath":"182","messages":"183","suppressedMessages":"184","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"185","messages":"186","suppressedMessages":"187","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"188","messages":"189","suppressedMessages":"190","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"191","messages":"192","suppressedMessages":"193","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"194","messages":"195","suppressedMessages":"196","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"170"},{"filePath":"197","messages":"198","suppressedMessages":"199","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"174"},{"filePath":"200","messages":"201","suppressedMessages":"202","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"203","messages":"204","suppressedMessages":"205","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181"},{"filePath":"206","messages":"207","suppressedMessages":"208","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"209","messages":"210","suppressedMessages":"211","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"212","messages":"213","suppressedMessages":"214","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"215","messages":"216","suppressedMessages":"217","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"218","messages":"219","suppressedMessages":"220","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"221"},{"filePath":"222","messages":"223","suppressedMessages":"224","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"225","messages":"226","suppressedMessages":"227","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"170"},{"filePath":"228","messages":"229","suppressedMessages":"230","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"174"},{"filePath":"231","messages":"232","suppressedMessages":"233","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"234","messages":"235","suppressedMessages":"236","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"181"},{"filePath":"237","messages":"238","suppressedMessages":"239","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"240","messages":"241","suppressedMessages":"242","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"243","messages":"244","suppressedMessages":"245","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"246","messages":"247","suppressedMessages":"248","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"249","messages":"250","suppressedMessages":"251","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"252","messages":"253","suppressedMessages":"254","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"255","messages":"256","suppressedMessages":"257","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"258","messages":"259","suppressedMessages":"260","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"261","messages":"262","suppressedMessages":"263","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"264","messages":"265","suppressedMessages":"266","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"267"},{"filePath":"268","messages":"269","suppressedMessages":"270","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"271"},{"filePath":"272","messages":"273","suppressedMessages":"274","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"275"},{"filePath":"276","messages":"277","suppressedMessages":"278","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"279","messages":"280","suppressedMessages":"281","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"282"},{"filePath":"283","messages":"284","suppressedMessages":"285","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"286","messages":"287","suppressedMessages":"288","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"289","messages":"290","suppressedMessages":"291","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"292","messages":"293","suppressedMessages":"294","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"295","messages":"296","suppressedMessages":"297","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"298","messages":"299","suppressedMessages":"300","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"301","messages":"302","suppressedMessages":"303","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"304"},{"filePath":"305","messages":"306","suppressedMessages":"307","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"308"},{"filePath":"309","messages":"310","suppressedMessages":"311","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"312"},{"filePath":"313","messages":"314","suppressedMessages":"315","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"316"},{"filePath":"317","messages":"318","suppressedMessages":"319","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"320","messages":"321","suppressedMessages":"322","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"323","messages":"324","suppressedMessages":"325","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"326"},"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/_app.js",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/index.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v1/index.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v2/index.jsx",["327"],[],"import React, { useState, Suspense } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport { Environment, OrthographicCamera, useGLTF } from '@react-three/drei';\nimport FullScreenContainer from '../../../components/mood-tracker/v1/FullScreenContainer';\nimport IconBarPlaceholder from '../../../components/mood-tracker/v1/IconBarPlaceholder';\nimport GameModal from '../../../components/mood-tracker/v1/GameModal';\nimport TextInputModal from '../../../components/mood-tracker/v1/TextInputModal';\nimport ScaledScene from '../../../components/mood-tracker/v1/ScaledScene';\nimport EmotionColumn from '../../../components/mood-tracker/v1/EmotionColumn';\nimport { FallingModelsScene } from '../../../components/mood-tracker/v1/FallingModels';\n\n// --- 데이터 정의: 이모티콘별 키워드 ---\n// const emojiKeywords = { ... }; // Moved to components/mood-tracker/v1/constants.js\n\n// --- 스타일 컴포넌트: 전체 화면 컨테이너 ---\n// const FullScreenContainer = ({ children }) => ( ... ); // Moved\n\n// --- UI 컴포넌트: 하단 이모티콘 선택 바 ---\n// const IconBarPlaceholder = ({ onEmojiSelect }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 게임 모달 (이모티콘 클릭 시 표시) ---\n// const GameModal = ({ isOpen, emoji, onClose }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 첫 화면 텍스트 입력 모달 ---\n// const TextInputModal = ({ isOpen, onClose, currentText, onTextChange, onSubmit }) => { ... }; // Moved\n\n// --- 3D 씬 컴포넌트: 저울 모델 및 크기 조정 로직 ---\n// function ScaledScene(props) { ... }; // Moved\n\n// --- 감정 컬럼(프레임) 컴포넌트 ---\n// function EmotionColumn({ emoji = '😀', keywords = [], sliderValue = 50, onSliderChange }) { ... }; // Moved\n\n// --- 메인 페이지 컴포넌트: MoodTrackerPage ---\nexport default function MoodTrackerPage() {\n  const [showLanding, setShowLanding] = useState(true);\n  const [isHovered, setIsHovered] = useState(false);\n  const [isGameModalOpen, setIsGameModalOpen] = useState(false);\n  const [selectedEmojiForGame, setSelectedEmojiForGame] = useState(null);\n  const [isTextInputModalOpen, setIsTextInputModalOpen] = useState(false);\n  const [userInputText, setUserInputText] = useState('');\n\n  const bodyProps = { position: [0, 0.5, 0], scale: 1.9, rotation: [0, 0, 0] };\n  const wingsProps = { position: [0, -0.02, 0], scale: 1.1, rotation: [0, 0, 0] };\n  const wingsPrimitiveOffset = [0, 0, 0];\n\n  const handleEmojiSelectForGame = (emoji) => {\n    setSelectedEmojiForGame(emoji);\n    setIsGameModalOpen(true);\n  };\n\n  const closeGameModal = () => {\n    setIsGameModalOpen(false);\n    setSelectedEmojiForGame(null);\n  };\n\n  const handlePlayClick = () => {\n    setIsTextInputModalOpen(true);\n  };\n\n  const handleTextInputSubmit = (text) => {\n    setUserInputText(text);\n    setShowLanding(false);\n  };\n\n  const keywords = ['기쁨', '즐거움', '행복함', '밝음', '신남', '부드러움', '통통튀는', '화창한']; // This can remain or be moved if it's specific to a component\n\n  // --- 첫 화면 3D 모델 애니메이션 컴포넌트 ---\n  // const EMOTION_MODEL_PATHS = [ ... ]; // Moved\n  // const NUM_FALLING_MODELS = 100; // Moved\n  // const FALLING_MODEL_SCALE = 40; // Moved\n  // const FALL_SPEED_MIN = 0.005; // Moved\n  // const FALL_SPEED_MAX = 0.015; // Moved\n\n  // EMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path)); // Moved to FallingModels.jsx\n\n  // function FallingEmotionModel({ modelPath, initialX, initialY, viewportHeight, modelScale }) { ... }; // Moved\n\n  // function FallingModelsScene() { ... }; // Moved and exported\n\n  if (showLanding) {\n    return (\n      <div style={{\n        width: '100vw',\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        background: '#B02B3A',\n        flexDirection: 'column',\n        position: 'relative',\n        overflow: 'hidden'\n      }}>\n        <div style={{\n          position: 'absolute',\n          top: '80px',\n          left: 0,\n          width: '100%',\n          height: '20vh',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          zIndex: 1,\n          color: 'rgba(255, 255, 255, 0.66)',\n          fontSize: 'calc(min(30vw, 35vh))',\n          fontWeight: 'bold',\n          fontFamily: 'Arial, sans-serif',\n          textAlign: 'center',\n          pointerEvents: 'none',\n          textTransform: 'uppercase'\n        }}>\n          MoMo\n        </div>\n        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', zIndex: 2 }}>\n          <Canvas>\n            <OrthographicCamera\n              makeDefault\n              position={[0, 0, 100]} \n              zoom={25}\n            />\n            <Suspense fallback={null}>\n              <FallingModelsScene />\n            </Suspense>\n          </Canvas>\n        </div>\n        <button\n          onClick={handlePlayClick}\n          style={{\n            padding: '50px 100px',\n            fontSize: '60px',\n            cursor: 'pointer',\n            background: 'white',\n            color: '#B02B3A',\n            border: '5px solid white',\n            borderRadius: '25px',\n            fontWeight: 'bold',\n            boxShadow: '0 12px 24px rgba(0,0,0,0.4)',\n            zIndex: 3,\n            position: 'absolute',\n            bottom: '100px',\n            left: '50%',\n            transform: 'translateX(-50%)'\n          }}\n        >\n          Play\n        </button>\n        <TextInputModal\n          isOpen={isTextInputModalOpen}\n          onClose={() => setIsTextInputModalOpen(false)}\n          currentText={userInputText}\n          onTextChange={setUserInputText}\n          onSubmit={handleTextInputSubmit}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <FullScreenContainer>\n      {userInputText && (\n        <div style={{\n          position: 'absolute',\n          top: '30px',\n          left: '50%',\n          transform: 'translateX(-50%)',\n          padding: '12px 25px',\n          background: 'rgba(255, 255, 255, 0.85)',\n          borderRadius: '12px',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.15)',\n          fontSize: '20px',\n          fontWeight: '500',\n          color: '#333',\n          zIndex: 100,\n          textAlign: 'center',\n          minWidth: '200px',\n          maxWidth: '80%',\n        }}>\n          {userInputText}\n        </div>\n      )}\n      <div style={{ display: 'flex', width: '100%', height: '100%', justifyContent: 'space-between', alignItems: 'center', position: 'absolute', top: 0, left: 0, zIndex: 1 }}>\n        <EmotionColumn emoji=\"😀\" keywords={keywords} sliderValue={30} />\n        <EmotionColumn emoji=\"😞\" keywords={keywords} sliderValue={70} />\n      </div>\n      <div style={{ width: '90%', height: '90%', maxWidth: '1200px', maxHeight: '900px', position: 'relative', zIndex: 2 }}>\n        <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}> \n          <Suspense fallback={null}>\n            <ambientLight intensity={0.25} color=\"#FFFFFF\" />\n            <directionalLight \n              position={[8, 10, 5]} \n              intensity={0.2} \n              castShadow\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n            />\n            <directionalLight \n              position={[-8, 5, -8]} \n              intensity={0.1}\n              color=\"#E3F2FD\"\n            />\n            <Environment preset=\"sunset\" intensity={0.8} blur={0.5} />\n            <ScaledScene\n              isHovered={isHovered}\n              onHover={setIsHovered}\n              bodyProps={bodyProps}\n              wingsProps={wingsProps}\n              wingsPrimitiveOffset={wingsPrimitiveOffset}\n              tiltAngle={Math.PI / 20}\n              verticalMovementFactor={0.03}\n            />\n          </Suspense>\n        </Canvas>\n      </div>\n      <IconBarPlaceholder onEmojiSelect={handleEmojiSelectForGame} />\n      <GameModal isOpen={isGameModalOpen} emoji={selectedEmojiForGame} onClose={closeGameModal} />\n    </FullScreenContainer>\n  );\n}","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v3/index.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v4/index.jsx",["328","329","330","331","332","333"],[],"import React, { useState, Suspense, useRef } from 'react';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { Environment, OrthographicCamera, useGLTF } from '@react-three/drei';\nimport { Physics } from '@react-three/rapier';\nimport FullScreenContainer from '../../../components/mood-tracker/v4/FullScreenContainer';\nimport GameModal from '../../../components/mood-tracker/v4/GameModal';\nimport TextInputModal from '../../../components/mood-tracker/v4/TextInputModal';\nimport ScaledScene from '../../../components/mood-tracker/v4/ScaledScene';\nimport EmotionColumn from '../../../components/mood-tracker/v4/EmotionColumn';\nimport { FallingModelsScene } from '../../../components/mood-tracker/v4/FallingModels';\nimport EmojiSelector3D from '../../../components/mood-tracker/v4/EmojiSelector3D';\nimport Emoji3D from '../../../components/mood-tracker/v4/Emoji3D';\nimport FallingEmojiManager from '../../../components/mood-tracker/v4/FallingEmojiManager';\nimport { FallingSelectedEmojiScene } from '../../../components/mood-tracker/v4/FallingSelectedEmojiScene';\n\n// Emoji ID와 실제 Emoji 문자를 매핑합니다.\nconst emojiIdToChar = {\n  'joy': '😀',\n  'surprise': '😮',\n  'neutral': '😐',\n  'sadness': '😖',\n  'anger': '😠',\n};\n\n// --- 데이터 정의: 이모티콘별 키워드 ---\n// const emojiKeywords = { ... }; // Moved to components/mood-tracker/v4/constants.js\n\n// --- 스타일 컴포넌트: 전체 화면 컨테이너 ---\n// const FullScreenContainer = ({ children }) => ( ... ); // Moved\n\n// --- UI 컴포넌트: 하단 이모티콘 선택 바 ---\n// const IconBarPlaceholder = ({ onEmojiSelect }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 게임 모달 (이모티콘 클릭 시 표시) ---\n// const GameModal = ({ isOpen, emoji, onClose }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 첫 화면 텍스트 입력 모달 ---\n// const TextInputModal = ({ isOpen, onClose, currentText, onTextChange, onSubmit }) => { ... }; // Moved\n\n// --- 3D 씬 컴포넌트: 저울 모델 및 크기 조정 로직 ---\n// function ScaledScene(props) { ... }; // Moved\n\n// --- 감정 컬럼(프레임) 컴포넌트 ---\n// function EmotionColumn({ emoji = '😀', keywords = [], sliderValue = 50, onSliderChange }) { ... }; // Moved\n\n// --- UI 컴포넌트: 게임 생성 모달 ---\nconst GameCreationModal = ({ isOpen, keyword, dominantEmojis = [], dominantKeywords, onClose, onStart }) => {\n  if (!isOpen) return null;\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      background: 'linear-gradient(135deg, #B02B3A 0%, #8B1E2B 100%)',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      zIndex: 2000,\n      animation: 'fadeIn 0.3s ease-in-out',\n      overflow: 'hidden'\n    }}>\n      {/* 3D 떨어지는 이모티콘 배경 */}\n      <div style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        zIndex: 1\n      }}>\n        <Canvas camera={{ position: [0, 0, 5], fov: 50 }}>\n          <Suspense fallback={null}>\n            <ambientLight intensity={0.7} />\n            <directionalLight position={[0, 10, 10]} intensity={1} />\n            <directionalLight position={[0, -10, -5]} intensity={0.3} />\n            <FallingSelectedEmojiScene dominantEmojis={dominantEmojis} />\n          </Suspense>\n        </Canvas>\n      </div>\n\n      <div style={{\n        width: '80vw',\n        height: '70vh',\n        maxWidth: '800px',\n        maxHeight: '600px',\n        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n        border: '3px solid #B02B3A',\n        borderRadius: '20px',\n        boxShadow: '0 15px 30px rgba(0, 0, 0, 0.3)',\n        padding: '40px',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        gap: '30px',\n        position: 'relative',\n        backdropFilter: 'blur(10px)',\n        animation: 'slideIn 0.4s ease-out',\n        zIndex: 10\n      }}>\n        {/* 닫기 버튼 */}\n        <button\n          onClick={onClose}\n          style={{\n            position: 'absolute',\n            top: '15px',\n            right: '20px',\n            background: 'none',\n            border: 'none',\n            fontSize: '30px',\n            cursor: 'pointer',\n            color: '#B02B3A',\n            fontWeight: 'bold',\n            transition: 'transform 0.2s ease'\n          }}\n          onMouseOver={(e) => {\n            e.target.style.transform = 'scale(1.1)';\n          }}\n          onMouseOut={(e) => {\n            e.target.style.transform = 'scale(1)';\n          }}\n        >\n          ×\n        </button>\n\n        {/* 우세한 이모티콘들 표시 */}\n        <div style={{\n          fontSize: dominantEmojis.length > 1 ? '80px' : '120px',\n          marginBottom: '10px',\n          textShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'bounce 2s ease-in-out infinite',\n          display: 'flex',\n          flexWrap: 'wrap',\n          justifyContent: 'center',\n          alignItems: 'center',\n          gap: dominantEmojis.length > 1 ? '10px' : '0'\n        }}>\n          {dominantEmojis.length > 0 ? dominantEmojis.map((emoji, index) => (\n            <span key={index} style={{\n              fontSize: dominantEmojis.length > 3 ? '60px' : dominantEmojis.length > 1 ? '80px' : '120px'\n            }}>\n              {emoji}\n            </span>\n          )) : '😀'}\n        </div>\n\n        {/* 메인 문구 */}\n        <h1 style={{\n          textAlign: 'center',\n          fontSize: '28px',\n          fontWeight: 'bold',\n          color: '#B02B3A',\n          margin: '0',\n          lineHeight: '1.4',\n          animation: 'fadeInUp 0.6s ease-out'\n        }}>\n          오늘의 감정 생물을 만들어 보아요!\n        </h1>\n\n        {/* 키워드 표시 */}\n        <div style={{\n          padding: '15px 30px',\n          background: '#D2F2E9',\n          borderRadius: '25px',\n          fontSize: '18px',\n          fontWeight: '600',\n          color: '#333',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'fadeInUp 0.8s ease-out',\n          textAlign: 'center',\n          minHeight: '50px',\n          display: 'flex',\n          flexWrap: 'wrap',\n          gap: '8px',\n          alignItems: 'center',\n          justifyContent: 'center'\n        }}>\n          {dominantKeywords && dominantKeywords.length > 0 ? (\n            dominantKeywords.map((keyword, index) => (\n              <span key={index} style={{\n                padding: '5px 12px',\n                borderRadius: '15px',\n                fontSize: '20px'\n              }}>\n                {keyword}\n              </span>\n            ))\n          ) : (\n            <span style={{ color: '#666', fontSize: '16px' }}>\n              감정 키워드가 없습니다\n            </span>\n          )}\n        </div>\n\n        {/* 게임 시작 버튼 */}\n        <button \n          style={{\n            padding: '15px 40px',\n            fontSize: '25px',\n            fontWeight: 'medium',\n            background: '#B02B3A',\n            color: 'white',\n            border: 'none',\n            borderRadius: '15px',\n            cursor: 'pointer',\n            boxShadow: '0 6px 12px rgba(176, 43, 58, 0.3)',\n            transition: 'all 0.3s ease',\n            marginTop: '20px',\n            animation: 'fadeInUp 1s ease-out'\n          }}\n          onMouseOver={(e) => {\n            e.target.style.transform = 'translateY(-2px)';\n            e.target.style.boxShadow = '0 8px 16px rgba(176, 43, 58, 0.4)';\n          }}\n          onMouseOut={(e) => {\n            e.target.style.transform = 'translateY(0)';\n            e.target.style.boxShadow = '0 6px 12px rgba(176, 43, 58, 0.3)';\n          }}\n          onClick={onStart}\n        >\n          Start\n        </button>\n      </div>\n\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes slideIn {\n          from { \n            opacity: 0;\n            transform: scale(0.8);\n          }\n          to { \n            opacity: 1;\n            transform: scale(1);\n          }\n        }\n        @keyframes fadeInUp {\n          from {\n            opacity: 0;\n            transform: translateY(20px);\n          }\n          to {\n            opacity: 1;\n            transform: translateY(0);\n          }\n        }\n        @keyframes bounce {\n          0%, 20%, 50%, 80%, 100% { transform: translateY(0); }\n          40% { transform: translateY(-10px); }\n          60% { transform: translateY(-5px); }\n        }\n        @keyframes fall {\n          0% {\n            transform: translateY(-50px) rotate(0deg);\n            opacity: 1;\n          }\n          100% {\n            transform: translateY(100vh) rotate(360deg);\n            opacity: 0;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\n// Float효과를 위한 3D 모델 컴포넌트\nconst FloatingModel = ({ url, position, rotationSpeed = 0.01, floatSpeed = 0.02, floatAmplitude = 0.5, scale = [0.8, 0.8, 0.8] }) => {\n  const mesh = useRef();\n  const { scene } = useGLTF(url);\n  \n  useFrame((state) => {\n    if (mesh.current) {\n      // 둥실거리는 효과\n      mesh.current.position.y = position[1] + Math.sin(state.clock.elapsedTime * floatSpeed) * floatAmplitude;\n      // 회전 효과\n      mesh.current.rotation.y += rotationSpeed;\n      mesh.current.rotation.x += rotationSpeed * 0.5;\n    }\n  });\n\n  return (\n    <primitive \n      ref={mesh} \n      object={scene.clone()} \n      position={position} \n      scale={scale}\n    />\n  );\n};\n\n// --- 생물 만들기 페이지 컴포넌트 ---\nconst CreationPage = ({ onBack, keyword, dominantEmojis, dominantKeywords }) => {\n  return (\n    <div style={{\n      width: '100vw',\n      height: '100vh',\n      background: 'url(/second.jpg) center/cover no-repeat',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      fontFamily: 'Arial, sans-serif',\n      animation: 'fadeIn 0.5s ease-in-out',\n      position: 'relative'\n    }}>\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n      `}</style>\n      \n      {/* 상단에 우세한 이모티콘과 키워드 표시 */}\n      <div style={{\n        position: 'absolute',\n        top: '30px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        background: 'rgba(255, 255, 255, 0.9)',\n        borderRadius: '15px',\n        padding: '20px',\n        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n        zIndex: 100,\n        textAlign: 'center',\n        minWidth: '300px',\n        maxWidth: '80%'\n      }}>\n        {/* 우세한 이모티콘 표시 */}\n        <div style={{\n          fontSize: '60px',\n          marginBottom: '10px',\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          gap: '10px',\n          flexWrap: 'wrap'\n        }}>\n          {dominantEmojis && dominantEmojis.length > 0 ? dominantEmojis.map((emoji, index) => (\n            <span key={index}>{emoji}</span>\n          )) : '😀'}\n        </div>\n        \n        {/* 키워드 표시 */}\n        <div style={{\n          display: 'flex',\n          flexWrap: 'wrap',\n          gap: '8px',\n          justifyContent: 'center',\n          alignItems: 'center'\n        }}>\n          {dominantKeywords && dominantKeywords.length > 0 ? (\n            dominantKeywords.map((keyword, index) => (\n              <span key={index} style={{\n                padding: '5px 12px',\n                background: '#D2F2E9',\n                borderRadius: '15px',\n                fontSize: '16px',\n                fontWeight: '500',\n                color: '#333'\n              }}>\n                {keyword}\n              </span>\n            ))\n          ) : (\n            <span style={{ color: '#666', fontSize: '14px' }}>\n              감정 키워드가 없습니다\n            </span>\n          )}\n        </div>\n      </div>\n      \n      {/* 3D 씬 */}\n      <Canvas camera={{ position: [0, 0, 10], fov: 50 }}>\n        <Suspense fallback={null}>\n          <ambientLight intensity={0.6} />\n          <directionalLight position={[10, 10, 5]} intensity={1} />\n          <directionalLight position={[-10, -10, -5]} intensity={0.3} />\n          \n          {/* 4개의 3D 모델들을 중앙 주변에 배치 */}\n          <FloatingModel \n            url=\"/box.gltf\" \n            position={[-4, 0, 0]} \n            rotationSpeed={0.008}\n            floatSpeed={0.015}\n            floatAmplitude={0.3}\n            scale={[1,1,1]}\n          />\n          <FloatingModel \n            url=\"/clinder.gltf\" \n            position={[-1.3, 0, 0]} \n            rotationSpeed={0.012}\n            floatSpeed={0.02}\n            floatAmplitude={0.4}\n            scale={[1,1,1]}\n          />\n          <FloatingModel \n            url=\"/hexagon.gltf\" \n            position={[1.3, 0, 0]} \n            rotationSpeed={0.01}\n            floatSpeed={0.018}\n            floatAmplitude={0.35}\n            scale={[1,1,1]}\n          />\n          <FloatingModel \n            url=\"/star.gltf\" \n            position={[4, 0, 0]} \n            rotationSpeed={0.015}\n            floatSpeed={0.025}\n            floatAmplitude={0.45}\n            scale={[1,1,1]}\n          />\n        </Suspense>\n      </Canvas>\n    </div>\n  );\n};\n\n// --- 메인 페이지 컴포넌트: MoodTrackerPage ---\nexport default function MoodTrackerPage() {\n  const [showLanding, setShowLanding] = useState(true);\n  const [isGameModalOpen, setIsGameModalOpen] = useState(false);\n  const [selectedEmojiForGameModal, setSelectedEmojiForGameModal] = useState(null);\n  const [isTextInputModalOpen, setIsTextInputModalOpen] = useState(false);\n  const [userInputText, setUserInputText] = useState('');\n  const [positiveEmojis, setPositiveEmojis] = useState([]); // 긍정 이모티콘들\n  const [negativeEmojis, setNegativeEmojis] = useState([]); // 부정 이모티콘들\n  const [positiveKeywords, setPositiveKeywords] = useState([]); // 긍정 키워드들\n  const [negativeKeywords, setNegativeKeywords] = useState([]); // 부정 키워드들\n  const [leftSliderValue, setLeftSliderValue] = useState(3);\n  const [rightSliderValue, setRightSliderValue] = useState(7);\n  const [isGameCreationModalOpen, setIsGameCreationModalOpen] = useState(false); // 게임 생성 모달 상태\n  const [showCreationPage, setShowCreationPage] = useState(false); // 생물 만들기 페이지 상태\n  \n  // 실제로 바구니에 떨어진 이모티콘 개수 추적\n  const [actualLeftCount, setActualLeftCount] = useState(0);\n  const [actualRightCount, setActualRightCount] = useState(0);\n\n  // 슬라이더 값에 따른 저울 기울기 계산\n  const calculateTiltAngle = () => {\n    const difference = rightSliderValue - leftSliderValue;\n    const maxTilt = Math.PI / 8; // 최대 기울기 각도를 좀 더 크게 (22.5도)\n    const normalizedDifference = difference / 10; // 슬라이더는 0-10 범위이므로\n    const tiltAngle = normalizedDifference * maxTilt;\n    \n    // 디버깅용 로그 (나중에 제거 가능)\n    console.log(`Left: ${leftSliderValue}, Right: ${rightSliderValue}, Difference: ${difference}, TiltAngle: ${tiltAngle}`);\n    \n    return tiltAngle; // 양수면 오른쪽으로 기울어짐, 음수면 왼쪽으로 기울어짐\n  };\n\n  const dynamicTiltAngle = calculateTiltAngle();\n\n  const bodyProps = { position: [0, 0.5, 0], scale: 1.9, rotation: [0, 0, 0] };\n  const wingsProps = { position: [0, -0.02, 0], scale: 1.1, rotation: [0, 0, 0] };\n  const wingsPrimitiveOffset = [0, 0, 0];\n\n  const handleEmoji3DClick = (emojiId) => {\n    const emojiChar = emojiIdToChar[emojiId];\n    if (emojiChar) {\n      setSelectedEmojiForGameModal(emojiChar);\n      setIsGameModalOpen(true);\n    }\n  };\n\n  const closeGameModal = () => {\n    setIsGameModalOpen(false);\n    setSelectedEmojiForGameModal(null);\n  };\n\n  const handleEmojiSelection = (emoji, keywords, type) => {\n    if (type === 'positive') {\n      setPositiveEmojis(prev => [...prev, emoji]);\n      setPositiveKeywords(prev => [...prev, ...keywords]);\n    } else if (type === 'negative') {\n      setNegativeEmojis(prev => [...prev, emoji]);\n      setNegativeKeywords(prev => [...prev, ...keywords]);\n    }\n    closeGameModal();\n  };\n\n  const handleKeywordUpdate = (emoji, keywords) => {\n    // 키워드 업데이트 기능 (필요시 구현)\n  };\n\n  const handlePlayClick = () => {\n    setIsTextInputModalOpen(true);\n  };\n\n  const handleTextInputSubmit = (text) => {\n    setUserInputText(text);\n    setShowLanding(false);\n  };\n\n  const handleStartGame = () => {\n    setIsGameCreationModalOpen(true);\n  };\n\n  const closeGameCreationModal = () => {\n    setIsGameCreationModalOpen(false);\n  };\n\n  const handleStartCreation = () => {\n    setIsGameCreationModalOpen(false);\n    setShowCreationPage(true);\n  };\n\n  const handleBackToMain = () => {\n    setShowCreationPage(false);\n  };\n\n  // 이모티콘이 바구니에 도달했을 때 처리하는 함수\n  const handleEmojiLanded = (landedInfo) => {\n    const { emojiType, basket, position } = landedInfo;\n    \n    console.log(`${emojiType} landed in ${basket} basket at position:`, position);\n    \n    // 실제 바구니에 떨어진 개수 증가\n    if (basket === 'left') {\n      setActualLeftCount(prev => prev + 1);\n    } else if (basket === 'right') {\n      setActualRightCount(prev => prev + 1);\n    }\n  };\n\n  // 우세한 이모티콘들 결정 (배열로 변경)\n  const dominantEmojis = actualLeftCount > actualRightCount ? positiveEmojis : negativeEmojis;\n  \n  // 우세한 키워드 가져오기\n  const dominantKeywords = actualLeftCount > actualRightCount ? positiveKeywords : negativeKeywords;\n\n  const keywords = ['기쁨', '즐거움', '행복함', '밝음', '신남', '부드러움', '통통튀는', '화창한'];\n\n  // Implementation of showCreationPage\n  if (showCreationPage) {\n    return (\n      <CreationPage\n        onBack={handleBackToMain}\n        keyword={userInputText || '감정'}\n        dominantEmojis={dominantEmojis}\n        dominantKeywords={dominantKeywords}\n      />\n    );\n  }\n\n  if (showLanding) {\n    return (\n      <div style={{\n        width: '100vw',\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        background: 'url(/first.png) center/cover no-repeat',\n        flexDirection: 'column',\n        position: 'relative',\n        overflow: 'hidden'\n      }}>\n        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', zIndex: 2 }}>\n          <Canvas>\n            <OrthographicCamera\n              makeDefault\n              position={[0, 0, 100]} \n              zoom={25}\n            />\n            <Suspense fallback={null}>\n              <FallingModelsScene />\n            </Suspense>\n          </Canvas>\n        </div>\n        <button\n          onClick={handlePlayClick}\n          style={{\n            padding: '30px 60px',\n            fontSize: '36px',\n            cursor: 'pointer',\n            background: 'white',\n            color: '#B02B3A',\n            border: '5px solid white',\n            borderRadius: '25px',\n            fontWeight: 'bold',\n            boxShadow: '0 12px 24px rgba(0,0,0,0.4)',\n            zIndex: 3,\n            position: 'absolute',\n            bottom: '100px',\n            left: '50%',\n            transform: 'translateX(-50%)'\n          }}\n        >\n          Play\n        </button>\n        <TextInputModal\n          isOpen={isTextInputModalOpen}\n          onClose={() => setIsTextInputModalOpen(false)}\n          currentText={userInputText}\n          onTextChange={setUserInputText}\n          onSubmit={handleTextInputSubmit}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <FullScreenContainer>\n      {userInputText && (\n        <div style={{\n          position: 'absolute',\n          top: '30px',\n          left: '50%',\n          transform: 'translateX(-50%)',\n          padding: '12px 25px',\n          background: 'rgba(255, 255, 255, 0.85)',\n          borderRadius: '12px',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.15)',\n          fontSize: '20px',\n          fontWeight: '500',\n          color: '#333',\n          zIndex: 100,\n          textAlign: 'center',\n          minWidth: '200px',\n          maxWidth: '80%',\n        }}>\n          {userInputText}\n        </div>\n      )}\n      <div style={{ display: 'flex', width: '100%', height: '100%', justifyContent: 'space-between', alignItems: 'center', position: 'absolute', top: 0, left: 0, zIndex: 1 }}>\n        <EmotionColumn \n          emojis={positiveEmojis} \n          keywords={positiveKeywords} \n          sliderValue={leftSliderValue}\n          onSliderChange={setLeftSliderValue}\n          onStartGame={handleStartGame}\n        />\n        <EmotionColumn \n          emojis={negativeEmojis} \n          keywords={negativeKeywords} \n          sliderValue={rightSliderValue}\n          onSliderChange={setRightSliderValue}\n          onStartGame={handleStartGame}\n        />\n      </div>\n      <div style={{ width: '90%', height: '90%', maxWidth: '1200px', maxHeight: '900px', position: 'relative', zIndex: 2 }}>\n        <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}> \n          <Suspense fallback={null}>\n            <ambientLight intensity={0.25} color=\"#FFFFFF\" />\n            <directionalLight \n              position={[8, 10, 5]} \n              intensity={0.2} \n              castShadow\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n            />\n            <directionalLight \n              position={[-8, 5, -8]} \n              intensity={0.1}\n              color=\"#E3F2FD\"\n            />\n            <Environment preset=\"sunset\" intensity={0.8} blur={0.5} />\n                        <Physics>\n            <ScaledScene\n              bodyProps={bodyProps}\n              wingsProps={wingsProps}\n              wingsPrimitiveOffset={wingsPrimitiveOffset}\n              tiltAngle={dynamicTiltAngle}\n              verticalMovementFactor={0.03}\n            />\n              <EmojiSelector3D \n                onEmojiClick={handleEmoji3DClick} \n                />\n              <FallingEmojiManager\n                leftCount={positiveEmojis.length > 0 ? leftSliderValue : 0}\n                rightCount={negativeEmojis.length > 0 ? rightSliderValue : 0}\n                leftEmojiTypes={positiveEmojis}\n                rightEmojiTypes={negativeEmojis}\n                onEmojiLanded={handleEmojiLanded}\n              />\n            </Physics>\n          </Suspense>\n        </Canvas>\n      </div>\n      <GameModal \n        isOpen={isGameModalOpen} \n        emoji={selectedEmojiForGameModal} \n        onClose={closeGameModal} \n        onEmojiSelect={handleEmojiSelection}\n        onKeywordUpdate={handleKeywordUpdate}\n        existingKeywords={[]}\n      />\n      <GameCreationModal\n        isOpen={isGameCreationModalOpen}\n        keyword={userInputText || '감정'}\n        dominantEmojis={dominantEmojis}\n        dominantKeywords={dominantKeywords}\n        onClose={closeGameCreationModal}\n        onStart={handleStartCreation}\n      />\n    </FullScreenContainer>\n  );\n}","/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker.jsx",["334","335","336"],[],"import React, { useState, Suspense, useRef } from 'react';\nimport { Canvas, useThree, useFrame } from '@react-three/fiber';\nimport { OrbitControls, Environment, Text, useGLTF, OrthographicCamera } from '@react-three/drei';\nimport { useRouter } from 'next/router';\nimport Scale from '../components/Scale'; // Scale 컴포넌트 경로 확인 필요\n\n// --- 데이터 정의: 이모티콘별 키워드 ---\nconst emojiKeywords = {\n  '😀': ['행복', '기쁨', '웃음', '긍정', '즐거움'],\n  '😮': ['놀람', '충격', '경악', '어머나', '세상에'],\n  '😐': ['무표정', '보통', '그저그럼', '심드렁', '평온'],\n  '😖': ['괴로움', '혼란', '좌절', '스트레스', '찡그림'],\n  '😠': ['화남', '분노', '짜증', '불만', '격분'],\n};\n\n// --- 스타일 컴포넌트: 전체 화면 컨테이너 ---\nconst FullScreenContainer = ({ children }) => (\n  <div style={{\n    width: '100vw',\n    height: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    gap: '10px',\n    alignItems: 'center',\n    background: '#000000',\n    overflow: 'hidden',\n    position: 'relative'\n  }}>\n    {/* 배경 MOMO 텍스트 */}\n    <div style={{\n      position: 'absolute',\n      top: '50%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      fontSize: 'min(25vw, 25vh)',\n      fontWeight: 'bold',\n      color: 'rgba(255, 255, 255, 0.1)',\n      fontFamily: 'Arial, sans-serif',\n      pointerEvents: 'none',\n      zIndex: 0,\n      userSelect: 'none'\n    }}>\n      MOMO\n    </div>\n    {children}\n  </div>\n);\n\n// --- UI 컴포넌트: 하단 이모티콘 선택 바 ---\nconst IconBarPlaceholder = ({ onEmojiSelect }) => {\n  const emojis = ['😀', '😮', '😐', '😖', '😠']; \n  const [hoveredIndex, setHoveredIndex] = useState(null);\n  \n  return (\n    <div style={{\n      position: 'absolute',\n      bottom: '7vh',\n      left: 0,\n      width: '100%',\n      display: 'flex',\n      justifyContent: 'center',\n      gap: '30px',\n      zIndex: 20,\n    }}>\n      {emojis.map((emoji, index) => (\n        <div \n          key={index} \n          style={{\n          fontSize: '130px',\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          cursor: 'pointer',\n            transition: 'all 0.3s ease',\n            filter: hoveredIndex === index ? 'drop-shadow(0 0 20px #ffff00) brightness(1.5)' : 'none',\n            transform: hoveredIndex === index ? 'scale(1.1)' : 'scale(1)',\n          }} \n          onClick={() => onEmojiSelect(emoji)}\n          onMouseEnter={() => setHoveredIndex(index)}\n          onMouseLeave={() => setHoveredIndex(null)}\n        >\n          {emoji}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// --- UI 컴포넌트: 게임 생성 모달 ---\nconst GameCreationModal = ({ isOpen, keyword, dominantEmoji, onClose }) => {\n  if (!isOpen) return null;\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      background: 'linear-gradient(135deg, #B02B3A 0%, #8B1E2B 100%)',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      zIndex: 2000,\n      animation: 'fadeIn 0.3s ease-in-out'\n    }}>\n      {/* 배경 장식 요소들 */}\n      <div style={{\n        position: 'absolute',\n        top: '10%',\n        left: '10%',\n        width: '100px',\n        height: '100px',\n        background: 'rgba(255, 255, 255, 0.1)',\n        borderRadius: '50%',\n        animation: 'float 6s ease-in-out infinite'\n      }} />\n      <div style={{\n        position: 'absolute',\n        bottom: '15%',\n        right: '15%',\n        width: '150px',\n        height: '150px',\n        background: 'rgba(255, 255, 255, 0.05)',\n        borderRadius: '50%',\n        animation: 'float 8s ease-in-out infinite reverse'\n      }} />\n      <div style={{\n        position: 'absolute',\n        top: '20%',\n        right: '20%',\n        width: '80px',\n        height: '80px',\n        background: 'rgba(255, 255, 255, 0.08)',\n        borderRadius: '50%',\n        animation: 'float 7s ease-in-out infinite'\n      }} />\n\n      <div style={{\n        width: '80vw',\n        height: '70vh',\n        maxWidth: '800px',\n        maxHeight: '600px',\n        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n        border: '3px solid #B02B3A',\n        borderRadius: '20px',\n        boxShadow: '0 15px 30px rgba(0, 0, 0, 0.3)',\n        padding: '40px',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        gap: '30px',\n        position: 'relative',\n        backdropFilter: 'blur(10px)',\n        animation: 'slideIn 0.4s ease-out'\n      }}>\n        {/* 닫기 버튼 */}\n        <button\n          onClick={onClose}\n          style={{\n            position: 'absolute',\n            top: '15px',\n            right: '20px',\n            background: 'none',\n            border: 'none',\n            fontSize: '30px',\n            cursor: 'pointer',\n            color: '#B02B3A',\n            fontWeight: 'bold',\n            transition: 'transform 0.2s ease'\n          }}\n          onMouseOver={(e) => {\n            e.target.style.transform = 'scale(1.1)';\n          }}\n          onMouseOut={(e) => {\n            e.target.style.transform = 'scale(1)';\n          }}\n        >\n          ×\n        </button>\n\n        {/* 우세한 이모티콘 표시 */}\n        <div style={{\n          fontSize: '120px',\n          marginBottom: '10px',\n          textShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'bounce 2s ease-in-out infinite'\n        }}>\n          {dominantEmoji}\n        </div>\n\n        {/* 메인 문구 */}\n        <h1 style={{\n          textAlign: 'center',\n          fontSize: '28px',\n          fontWeight: 'bold',\n          color: '#B02B3A',\n          margin: '0',\n          lineHeight: '1.4',\n          animation: 'fadeInUp 0.6s ease-out'\n        }}>\n          \"{keyword}\"의 감정 생물을 만들어 보아요!\n        </h1>\n\n        {/* 키워드 표시 */}\n        <div style={{\n          padding: '15px 30px',\n          background: '#D2F2E9',\n          borderRadius: '25px',\n          fontSize: '20px',\n          fontWeight: '600',\n          color: '#333',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'fadeInUp 0.8s ease-out'\n        }}>\n          키워드: {keyword}\n        </div>\n\n        {/* 게임 시작 버튼 */}\n        <button style={{\n          padding: '15px 40px',\n          fontSize: '22px',\n          fontWeight: 'bold',\n          background: '#B02B3A',\n          color: 'white',\n          border: 'none',\n          borderRadius: '15px',\n          cursor: 'pointer',\n          boxShadow: '0 6px 12px rgba(176, 43, 58, 0.3)',\n          transition: 'all 0.3s ease',\n          marginTop: '20px',\n          animation: 'fadeInUp 1s ease-out'\n        }}\n        onMouseOver={(e) => {\n          e.target.style.transform = 'translateY(-2px)';\n          e.target.style.boxShadow = '0 8px 16px rgba(176, 43, 58, 0.4)';\n        }}\n        onMouseOut={(e) => {\n          e.target.style.transform = 'translateY(0)';\n          e.target.style.boxShadow = '0 6px 12px rgba(176, 43, 58, 0.3)';\n        }}>\n          생물 만들기 시작!\n        </button>\n      </div>\n\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes slideIn {\n          from { \n            opacity: 0;\n            transform: scale(0.8);\n          }\n          to { \n            opacity: 1;\n            transform: scale(1);\n          }\n        }\n        @keyframes fadeInUp {\n          from {\n            opacity: 0;\n            transform: translateY(20px);\n          }\n          to {\n            opacity: 1;\n            transform: translateY(0);\n          }\n        }\n        @keyframes float {\n          0%, 100% { transform: translateY(0px); }\n          50% { transform: translateY(-20px); }\n        }\n        @keyframes bounce {\n          0%, 20%, 50%, 80%, 100% { transform: translateY(0); }\n          40% { transform: translateY(-10px); }\n          60% { transform: translateY(-5px); }\n        }\n      `}</style>\n    </div>\n  );\n};\n\n// --- UI 컴포넌트: 게임 모달 ---\nconst GameModal = ({ isOpen, emoji, onClose, onPositiveNegativeSelect }) => {\n  const [currentKeywordInput, setCurrentKeywordInput] = React.useState('');\n  const [userKeywords, setUserKeywords] = React.useState([]);\n\n  React.useEffect(() => {\n    // 모달이 열리거나 대상 이모티콘이 변경될 때 입력 상태 초기화\n    if (isOpen) {\n      setCurrentKeywordInput('');\n      setUserKeywords([]);\n    } else {\n      // 모달이 닫힐 때도념のため 초기화 (선택적)\n      setCurrentKeywordInput('');\n      setUserKeywords([]);\n    }\n  }, [isOpen, emoji]); \n\n  if (!isOpen || !emoji) return null;\n\n  // const originalKeywords = emojiKeywords[emoji] || ['키워드 정보 없음']; // 원래 키워드 (참고용으로 남겨둘 수 있음)\n\n  const handleAddKeyword = () => {\n    if (currentKeywordInput.trim() !== '') {\n      setUserKeywords(prev => [...prev, currentKeywordInput.trim()]);\n      setCurrentKeywordInput('');\n    }\n  };\n\n  const handlePositiveClick = () => {\n    onPositiveNegativeSelect('positive');\n    onClose();\n  };\n\n  const handleNegativeClick = () => {\n    onPositiveNegativeSelect('negative');\n    onClose();\n  };\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: '48%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      width: '60vw',\n      height: 'auto', // 높이를 auto로 변경하여 내용에 따라 조절\n      minHeight: '40vh', // 최소 높이 설정\n      maxHeight: '70vh', // 최대 높이 설정\n      overflowY: 'auto', // 내용이 많으면 스크롤\n      maxWidth: '600px',\n      // maxHeight: '400px', // 이 부분은 내용에 따라 유동적이므로 주석 처리 또는 삭제\n      backgroundColor: 'rgba(255, 255, 255, 0.90)',\n      border: '2px solid #eee',\n      borderRadius: '10px',\n      boxShadow: '0 8px 13px rgba(0, 0, 0, 0.71)',\n      padding: '30px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      // justifyContent: 'flex-start', // 기본값으로 변경 또는 삭제\n      gap: '15px', // 요소 간 간격 조정\n      zIndex: 1000,\n    }}>\n      <span style={{ fontSize: '100px', marginBottom: '0px' }}>{emoji}</span> {/* 이모지 크기 약간 줄임 */}\n      <h2 style={{ textAlign: 'center', marginTop: '0px', marginBottom: '10px', fontSize: '22px' }}>오늘의 감정 이유</h2>\n      \n      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', width: '90%', marginBottom:'10px' }}>\n        <input \n          type=\"text\"\n          value={currentKeywordInput}\n          onChange={(e) => setCurrentKeywordInput(e.target.value)}\n          placeholder=\"선택 이유\"\n          style={{\n            flexGrow: 1,\n            padding: '10px 15px',\n            fontSize: '16px',\n            borderRadius: '5px',\n            border: '1px solid #ccc',\n            boxSizing: 'border-box'\n          }}\n          onKeyPress={(e) => {\n            if (e.key === 'Enter') {\n              handleAddKeyword();\n            }\n          }}\n        />\n        <button onClick={handleAddKeyword} style={{\n          padding: '10px 15px',\n          fontSize: '16px',\n          cursor: 'pointer',\n          background: '#5cb85c', // 초록색 계열 버튼\n          color: 'white',\n          border: 'none',\n          borderRadius: '5px'\n        }}>\n          추가\n        </button>\n      </div>\n\n      <div style={{ \n        display: 'flex', \n        flexWrap: 'wrap', \n        gap: '8px',  // 키워드 간 간격\n        justifyContent: 'center', \n        width: '100%', \n        padding: '10px 0', \n        minHeight: '50px' // 키워드가 없을 때도 최소 높이 유지\n      }}>\n        {userKeywords.length > 0 ? userKeywords.map((keyword, index) => (\n          <span key={index} style={{\n            padding: '8px 15px',\n            background: '#ffc0cb',\n            borderRadius: '30px',\n            fontSize: '18px' // 폰트 크기 통일\n          }}>\n            {keyword}\n          </span>\n        )) : (\n          <span style={{color: '#888', fontSize: '16px'}}>입력한 키워드가 여기에 표시됩니다.</span>\n        )}\n      </div>\n      \n      <div style={{ display: 'flex', gap: '15px', marginTop: '10px' }}>\n        <button onClick={handlePositiveClick} style={{\n          padding: '12px 25px',\n          fontSize: '18px',\n        cursor: 'pointer',\n        background: '#007bff',\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px'\n      }}>\n          긍정\n        </button>\n        <button onClick={handleNegativeClick} style={{\n          padding: '12px 25px',\n          fontSize: '18px',\n          cursor: 'pointer',\n          background: '#28a745',\n          color: 'white',\n          border: 'none',\n          borderRadius: '5px'\n        }}>\n          부정\n      </button>\n      </div>\n    </div>\n  );\n};\n\n// --- UI 컴포넌트: 첫 화면 텍스트 입력 모달 ---\nconst TextInputModal = ({ isOpen, onClose, currentText, onTextChange, onSubmit }) => {\n  if (!isOpen) return null;\n\n  const handleSubmit = () => {\n    onSubmit(currentText);\n    onClose();\n  };\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: '48%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      width: '60vw',\n      height: '60vh',\n      maxWidth: '600px',\n      maxHeight: '400px',\n      backgroundColor: 'rgba(255, 255, 255, 0.90)',\n      border: '2px solid #eee',\n      borderRadius: '10px',\n      boxShadow: '0 8px 13px rgba(0, 0, 0, 0.71)',\n      padding: '30px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      justifyContent: 'space-between', // 요소들 사이에 공간 배분\n      gap: '20px',\n      zIndex: 1001, // GameModal보다 위에, 또는 다른 모달과 겹치지 않게\n    }}>\n      <h2 style={{ textAlign: 'center', marginTop: '10px', marginBottom: '10px', fontSize: '30px', color: '#333' }}>\n        오늘의 무게 단어\n      </h2>\n      <textarea\n        value={currentText}\n        onChange={(e) => onTextChange(e.target.value)}\n        placeholder=\"단어 입력\"\n        style={{\n          width: '90%',\n          height: '100px', // 높이 조절\n          padding: '30px',\n          fontSize: '30px',\n          borderRadius: '8px',\n          border: '1px solid #ccc',\n          resize: 'none', // 사용자가 크기 조절 못하게\n          boxSizing: 'border-box',\n          textAlign: 'center',\n        }}\n      />\n      <button onClick={handleSubmit} style={{\n        padding: '12px 25px',\n        fontSize: '18px',\n        cursor: 'pointer',\n        background: '#007bff',\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px',\n        alignSelf: 'center', // 버튼 중앙 정렬\n      }}>\n        확인\n      </button>\n    </div>\n  );\n};\n\n// --- 3D 씬 컴포넌트: 저울 모델 및 크기 조정 로직 ---\nfunction ScaledScene(props) {\n  const { viewport, size } = useThree();\n  const aspect = size.width / size.height;\n  let scaleFactor;\n\n  if (aspect > 1) {\n    scaleFactor = viewport.height / 5.0; \n  } else {\n    scaleFactor = viewport.height / 6.0; \n  }\n\n  return (\n    <group \n      scale={[scaleFactor, scaleFactor, scaleFactor]}\n      rotation={[-Math.PI / 12, 0, 0]}\n    >\n      <Scale\n        isHovered={props.isHovered}\n        onHover={props.onHover}\n        bodyProps={props.bodyProps}\n        wingsProps={props.wingsProps}\n        wingsLeftProps={{ position: [-0, 0, 0], scale: 1, rotation: [0, 0, 0] }}\n        wingsRightProps={{ position: [0, 0, 0], scale: 1, rotation: [0, 0, 0] }}\n        wingsPrimitiveOffset={props.wingsPrimitiveOffset}\n        tiltAngle={props.tiltAngle}\n        verticalMovementFactor={props.verticalMovementFactor}\n      />\n    </group>\n  );\n}\n\n// --- 감정 컬럼(프레임) 컴포넌트 ---\nfunction EmotionColumn({ emoji = '😀', keywords = [], sliderValue = 50, onSliderChange, onStartGame }) {\n  const handleSliderClick = (event) => {\n    const rect = event.currentTarget.getBoundingClientRect();\n    const clickX = event.clientX - rect.left;\n    const sliderWidth = rect.width;\n    const newValue = Math.max(0, Math.min(100, (clickX / sliderWidth) * 100));\n    if (onSliderChange) {\n      onSliderChange(newValue);\n    }\n  };\n\n  return (\n    <div style={{\n      width: 260,\n      minWidth: 220,\n      minHeight: '100vh',\n      background: '#B02B3A',\n      borderRadius: 30,\n      padding: '24px 12px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      gap: 24,\n      boxShadow: '0 2px 12px rgba(0,0,0,0.08)'\n    }}>\n      <div style={{\n        width: '100%',\n        background: '#D2F2E9',\n        color: '#222',\n        fontWeight: 700,\n        fontSize: 22,\n        borderRadius: 12,\n        textAlign: 'center',\n        padding: '10px 0',\n        marginTop: 22, \n        marginBottom: 1\n      }}>감정 무게</div>\n      <div style={{\n        width: '90%',\n        background: 'white',\n        borderRadius: 18,\n        boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        padding: '18px 0 18px 0',\n        marginBottom: 30\n      }}>\n        <div style={{ fontSize: 60, marginBottom: 10 }}>{emoji}</div>\n        <div \n          style={{ \n            width: '80%', \n            height: 18, \n            background: '#BFE2D6', \n            borderRadius: 9, \n            position: 'relative', \n            margin: '10px 0',\n            cursor: 'pointer'\n          }}\n          onClick={handleSliderClick}\n        >\n          <div style={{\n            position: 'absolute',\n            left: `calc(${sliderValue}% - 18px)`,\n            top: -7,\n            width: 32,\n            height: 32,\n            background: '#E94B5A',\n            borderRadius: '50%',\n            boxShadow: '0 2px 6px rgba(0,0,0,0.13)',\n            border: '3px solid #fff',\n            transition: 'left 0.2s',\n            cursor: 'pointer'\n          }} />\n        </div>\n      </div>\n      <div style={{\n        width: '90%',\n        background: 'white',\n        borderRadius: 18,\n        boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n        padding: '16px 10px',\n        marginBottom: 8,\n        fontSize: 18,\n        color: '#222',\n        textAlign: 'left',\n        minHeight: 90,\n        display: 'flex',\n        flexDirection: 'column',\n        gap: 4\n      }}>\n        <div style={{ fontWeight: 700, fontSize: 18, marginBottom: 6 }}>감정 끝말잇기</div>\n        <div>\n          {keywords.map((k, i) => (\n            <span key={i} style={{ marginRight: 8 }}>{k}</span>\n          ))}\n        </div>\n      </div>\n      <div style={{ flex: 1 }} />\n      <button\n        style={{\n          width: '90%',\n          background: 'white',\n          color: '#B02B3A',\n          border: 'none',\n          borderRadius: 18,\n          fontWeight: 700,\n          fontSize: 20,\n          padding: '12px 0',\n          marginTop: 'auto',\n          marginBottom: 40,\n          boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n          cursor: 'pointer'\n        }}\n        onClick={onStartGame}\n      >만들기 시작</button>\n    </div>\n  );\n}\n\n// --- 메인 페이지 컴포넌트: MoodTrackerPage ---\nexport default function MoodTrackerPage() {\n  const router = useRouter();\n  const [showLanding, setShowLanding] = useState(true);\n  const [isHovered, setIsHovered] = useState(false);\n  const [isGameModalOpen, setIsGameModalOpen] = useState(false);\n  const [selectedEmojiForGame, setSelectedEmojiForGame] = useState(null);\n  const [isTextInputModalOpen, setIsTextInputModalOpen] = useState(false); // 텍스트 입력 모달 상태\n  const [userInputText, setUserInputText] = useState(''); // 사용자 입력 텍스트 상태\n  const [leftSliderValue, setLeftSliderValue] = useState(30); // 왼쪽 슬라이더 값\n  const [rightSliderValue, setRightSliderValue] = useState(70); // 오른쪽 슬라이더 값\n  const [isGameCreationModalOpen, setIsGameCreationModalOpen] = useState(false); // 게임 생성 모달 상태\n  const [showColumns, setShowColumns] = useState(false); // 양쪽 칼럼 표시 상태\n\n  const bodyProps = { position: [0, 0.5, 0], scale: 1.9, rotation: [0, 0, 0] };\n  const wingsProps = { position: [0, -0.02, 0], scale: 1.1, rotation: [0, 0, 0] };\n  const wingsPrimitiveOffset = [0, 0, 0];\n\n  const handleEmojiSelectForGame = (emoji) => {\n    setSelectedEmojiForGame(emoji);\n    setIsGameModalOpen(true);\n  };\n\n  const closeGameModal = () => {\n    setIsGameModalOpen(false);\n    setSelectedEmojiForGame(null);\n  };\n\n  const handlePlayClick = () => {\n    // setShowLanding(false); // 직접 화면 전환하는 대신 모달 열기\n    setIsTextInputModalOpen(true);\n  };\n\n  const handleTextInputSubmit = (text) => {\n    setUserInputText(text);\n    // 모달의 onClose가 호출되므로 여기서는 isTextInputModalOpen을 false로 설정할 필요 없음\n    setShowLanding(false); // 메인 화면으로 전환\n  };\n\n  const handleStartGame = () => {\n    // 슬라이더 값이 더 큰 이모티콘 결정\n    const dominantEmoji = leftSliderValue > rightSliderValue ? '😀' : '😞';\n    setIsGameCreationModalOpen(true);\n  };\n\n  const closeGameCreationModal = () => {\n    setIsGameCreationModalOpen(false);\n  };\n\n  // 슬라이더 값이 더 큰 이모티콘 결정\n  const dominantEmoji = leftSliderValue > rightSliderValue ? '😀' : '😞';\n\n  const keywords = ['기쁨', '즐거움', '행복함', '밝음', '신남', '부드러움', '통통튀는', '화창한'];\n\n  // --- 첫 화면 3D 모델 애니메이션 컴포넌트 ---\n  const EMOTION_MODEL_PATHS = [\n    '/models/emotion1.gltf',\n    '/models/emotion2.gltf',\n    '/models/emotion3.gltf',\n    '/models/emotion4.gltf',\n    '/models/emotion5.gltf',\n  ];\n  const NUM_FALLING_MODELS = 100; // 화면을 채울 모델 개수 증가\n  const FALLING_MODEL_SCALE = 40; // 떨어지는 모델 크기 증가\n  const FALL_SPEED_MIN = 0.005; // 이 값들은 이제 직접 사용되지 않음 (중력 기반으로 변경)\n  const FALL_SPEED_MAX = 0.015; // 이 값들은 이제 직접 사용되지 않음\n\n  EMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\n  function FallingEmotionModel({ modelPath, initialX, initialY, viewportHeight, modelScale }) {\n    const ref = React.useRef();\n    const { scene } = useGLTF(modelPath);\n    const clonedScene = React.useMemo(() => scene.clone(), [scene]);\n    \n    const [isHovered, setIsHovered] = useState(false);\n    const velocity = useRef({ x: 0, y: 0 }); // X, Y 속도\n    const [rotationSpeed] = useState(() => (Math.random() - 0.5) * 0.02);\n    const [xPos] = useState(initialX);\n\n\n    useFrame((state, delta) => {\n      if (ref.current) {\n        const currentVel = velocity.current;\n        const G_ACCEL = 0.0003;\n        const HOVER_SIDE_STRENGTH = 0.15; // 호버 시 좌우로 밀리는 힘 강도\n        const HOVER_UP_STRENGTH = 0.0008; // 호버 시 위로 밀리는 힘 강도 (중력 약간 상쇄)\n        const X_DAMPING = 0.92; // X축 이동 감속\n\n        // 중력 적용 (아래로 떨어지는 속도 증가)\n        currentVel.y += G_ACCEL * 80 * delta;\n\n        if (isHovered) {\n          // 호버 시 X축으로 랜덤하게 밀기\n          currentVel.x += (Math.random() - 0.5) * HOVER_SIDE_STRENGTH * 60 * delta;\n          // 호버 시 Y축 하강 속도 약간 줄이기 (위로 밀리는 효과)\n          currentVel.y -= HOVER_UP_STRENGTH * 60 * delta;\n        }\n\n        // 위치 업데이트\n        ref.current.position.x += currentVel.x * 60 * delta;\n        ref.current.position.y -= currentVel.y * 60 * delta; // Y 속도가 양수일 때 아래로 이동\n\n        // X축 감속\n        currentVel.x *= X_DAMPING;\n\n        // 회전\n        ref.current.rotation.y += rotationSpeed * 60 * delta;\n        ref.current.rotation.x += rotationSpeed * 0.5 * 60 * delta;\n\n        // 화면 하단 도달 시 리셋\n        if (ref.current.position.y < -viewportHeight / 2 - modelScale * 2) { // 여유값은 modelScale에 비례하게\n          ref.current.position.y = viewportHeight / 2 + modelScale * 2 + Math.random() * viewportHeight * 0.3;\n          ref.current.position.x = (Math.random() - 0.5) * state.viewport.width * 0.9;\n          currentVel.x = 0;\n          currentVel.y = 0; // 속도 초기화\n          setIsHovered(false); // 호버 상태도 리셋\n        }\n      }\n    });\n\n    return (\n      <primitive\n        ref={ref}\n        object={clonedScene}\n        scale={modelScale}\n        position={[xPos, initialY, 0]} // Z 위치 0으로 고정\n        onPointerOver={(event) => { \n          event.stopPropagation(); \n          setIsHovered(true); \n        }}\n        onPointerOut={() => setIsHovered(false)}\n      />\n    );\n  }\n\n  function FallingModelsScene() {\n    const { viewport } = useThree();\n    const models = [];\n\n    for (let i = 0; i < NUM_FALLING_MODELS; i++) {\n      const modelPath = EMOTION_MODEL_PATHS[i % EMOTION_MODEL_PATHS.length];\n      // 초기 Y 위치를 화면 상단 너머로 더 넓게 분산시키고, X 위치도 화면 전체에 걸쳐 랜덤하게 분산\n      const initialModelX = (Math.random() - 0.5) * viewport.width * 1.2; // X 범위를 약간 넓게\n      const initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + (i % (NUM_FALLING_MODELS / 5)) * (FALLING_MODEL_SCALE * 1.8) + Math.random() * FALLING_MODEL_SCALE;\n\n\n      models.push(\n        <FallingEmotionModel\n          key={`${modelPath}-${i}`} // 고유한 key 제공\n          modelPath={modelPath}\n          initialX={initialModelX}\n          initialY={initialModelY}\n          viewportHeight={viewport.height}\n          modelScale={FALLING_MODEL_SCALE}\n        />\n      );\n    }\n\n    return (\n      <>\n        <ambientLight intensity={0.7} />\n        <directionalLight position={[0, 10, 10]} intensity={1} />\n        <directionalLight position={[0, -10, -5]} intensity={0.3} />\n        {models}\n      </>\n    );\n  }\n\n  if (showLanding) {\n    return (\n      <div style={{\n        width: '100vw',\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        background: '#B02B3A',\n        flexDirection: 'column',\n        position: 'relative',\n        overflow: 'hidden'\n      }}>\n        <div style={{\n          position: 'absolute',\n          top: '80px',\n          left: 0,\n          width: '100%',\n          height: '20vh',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          zIndex: 1,\n          color: 'rgba(255, 255, 255, 0.66)',\n          fontSize: 'calc(min(30vw, 35vh))',\n          fontWeight: 'bold',\n          fontFamily: 'Arial, sans-serif',\n          textAlign: 'center',\n          pointerEvents: 'none',\n          textTransform: 'uppercase'\n        }}>\n          MoMo\n        </div>\n        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', zIndex: 2 }}>\n          <Canvas>\n            <OrthographicCamera\n              makeDefault\n              position={[0, 0, 100]} \n              zoom={25}\n            />\n            <Suspense fallback={null}>\n              <FallingModelsScene />\n            </Suspense>\n          </Canvas>\n        </div>\n        <button\n          onClick={handlePlayClick}\n          style={{\n            padding: '50px 100px',\n            fontSize: '60px',\n            cursor: 'pointer',\n            background: 'white',\n            color: '#B02B3A',\n            border: '5px solid white',\n            borderRadius: '25px',\n            fontWeight: 'bold',\n            boxShadow: '0 12px 24px rgba(0,0,0,0.4)',\n            zIndex: 3,\n            position: 'absolute',\n            bottom: '100px',\n            left: '50%',\n            transform: 'translateX(-50%)'\n          }}\n        >\n          Play\n        </button>\n        <TextInputModal\n          isOpen={isTextInputModalOpen}\n          onClose={() => setIsTextInputModalOpen(false)}\n          currentText={userInputText}\n          onTextChange={setUserInputText}\n          onSubmit={handleTextInputSubmit}\n        />\n      </div>\n    );\n  }\n\n  // 현재 날짜와 시간 가져오기\n  const getCurrentDateTime = () => {\n    const now = new Date();\n    const year = now.getFullYear();\n    const month = now.getMonth() + 1;\n    const day = now.getDate();\n    const dayNames = ['일', '월', '화', '수', '목', '금', '토'];\n    const dayName = dayNames[now.getDay()];\n    const hour = now.getHours();\n    const minute = now.getMinutes().toString().padStart(2, '0');\n    \n    return `${year}년 ${month}월 ${day}일 (${dayName}) 오후 ${hour}:${minute}`;\n  };\n\n  return (\n    <FullScreenContainer>\n      {/* 상단 헤더 정보 */}\n      <div style={{\n        position: 'absolute',\n        top: '20px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        width: '90%',\n        maxWidth: '1200px',\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        zIndex: 100,\n        padding: '0 20px'\n      }}>\n        {/* 왼쪽: 제목 */}\n        <div style={{\n          color: 'white',\n          fontSize: '18px',\n          fontWeight: '600'\n        }}>\n          이모티콘을 이용해 오늘의 감정 무게를 측정하고 기록하세요\n        </div>\n        \n        {/* 오른쪽: 오늘의 감정 기록하기와 날짜 */}\n        <div style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'flex-end',\n          gap: '5px'\n        }}>\n          <div style={{\n            color: 'white',\n            fontSize: '18px',\n            fontWeight: '600'\n          }}>\n            오늘의 감정 기록하기\n          </div>\n          <div style={{\n            color: 'rgba(255, 255, 255, 0.8)',\n            fontSize: '14px'\n          }}>\n            {getCurrentDateTime()}\n          </div>\n        </div>\n      </div>\n\n      {userInputText && (\n        <div style={{\n          position: 'absolute',\n          top: '80px', // 상단 헤더 아래로 이동\n          left: '50%',\n          transform: 'translateX(-50%)',\n          padding: '12px 25px',\n          background: 'rgba(255, 255, 255, 0.85)',\n          borderRadius: '12px',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.15)',\n          fontSize: '20px',\n          fontWeight: '500',\n          color: '#333',\n          zIndex: 100,\n          textAlign: 'center',\n          minWidth: '200px',\n          maxWidth: '80%',\n        }}>\n          {userInputText}\n        </div>\n      )}\n      {showColumns && (\n      <div style={{ display: 'flex', width: '100%', height: '100%', justifyContent: 'space-between', alignItems: 'center', position: 'absolute', top: 0, left: 0, zIndex: 1 }}>\n        <EmotionColumn emoji=\"😀\" keywords={keywords} sliderValue={leftSliderValue} onSliderChange={setLeftSliderValue} onStartGame={handleStartGame} />\n        <EmotionColumn emoji=\"😞\" keywords={keywords} sliderValue={rightSliderValue} onSliderChange={setRightSliderValue} onStartGame={handleStartGame} />\n      </div>\n      )}\n      <div style={{ width: '90%', height: '90%', maxWidth: '1200px', maxHeight: '900px', position: 'relative', zIndex: 2 }}>\n        <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}> \n          <Suspense fallback={null}>\n            <ambientLight intensity={0.25} color=\"#FFFFFF\" />\n            <directionalLight \n              position={[8, 10, 5]} \n              intensity={0.2} \n              castShadow\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n            />\n            <directionalLight \n              position={[-8, 5, -8]} \n              intensity={0.1}\n              color=\"#E3F2FD\"\n            />\n            <Environment preset=\"sunset\" intensity={0.8} blur={0.5} />\n            <ScaledScene\n              isHovered={isHovered}\n              onHover={setIsHovered}\n              bodyProps={bodyProps}\n              wingsProps={wingsProps}\n              wingsPrimitiveOffset={wingsPrimitiveOffset}\n              tiltAngle={Math.PI / 20}\n              verticalMovementFactor={0.03}\n            />\n          </Suspense>\n        </Canvas>\n      </div>\n      <IconBarPlaceholder onEmojiSelect={handleEmojiSelectForGame} />\n              <GameModal isOpen={isGameModalOpen} emoji={selectedEmojiForGame} onClose={closeGameModal} onPositiveNegativeSelect={(type) => {\n          // 긍정/부정 버튼 클릭 시 양쪽 칼럼 표시\n          setShowColumns(true);\n          console.log(`Selected ${type} emotion: ${selectedEmojiForGame}`);\n        }} />\n      <GameCreationModal\n        isOpen={isGameCreationModalOpen}\n        keyword={userInputText}\n        dominantEmoji={dominantEmoji}\n        onClose={closeGameCreationModal}\n      />\n    </FullScreenContainer>\n  );\n}","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Ax.jsx",["337"],[],"/*\nAuto-generated by: https://github.com/pmndrs/gltfjsx\n*/\n\nimport React, { useRef, useEffect } from 'react'\nimport { useGLTF } from '@react-three/drei'\nimport { useFrame } from '@react-three/fiber'\nimport * as THREE from 'three'\n\nexport default function Ax({ isHovered, onHover }) {\n  const meshRef = useRef()\n  const { scene } = useGLTF('/Ax.gltf')\n  const targetRotation = useRef(0)\n  const currentRotation = useRef(0)\n\n  useFrame(() => {\n    if (isHovered) {\n      targetRotation.current = Math.PI / 4 // 45도 (라디안)\n    } else {\n      targetRotation.current = 0\n    }\n\n    // 부드러운 회전을 위한 보간\n    currentRotation.current = THREE.MathUtils.lerp(\n      currentRotation.current,\n      targetRotation.current,\n      0.1\n    )\n\n    meshRef.current.rotation.x = currentRotation.current\n  })\n\n  return (\n    <mesh\n      ref={meshRef}\n      onPointerEnter={() => onHover(true)}\n      onPointerLeave={() => onHover(false)}\n    >\n      <primitive object={scene} scale={1} position={[0, 0, 0]} />\n    </mesh>\n  )\n}\n\nuseGLTF.preload('/Ax.gltf')\n","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Calumn.jsx",["338"],[],"/*\nAuto-generated by: https://github.com/pmndrs/gltfjsx\n*/\n\nimport React, { useRef } from 'react'\nimport { useGLTF } from '@react-three/drei'\n\nexport default function Calumn() {\n  const { scene } = useGLTF('/Calumn.gltf')\n  return <primitive object={scene} scale={1} position={[0, 0, 0]} />\n}\n\nuseGLTF.preload('/Calumn.gltf')\n","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/Scale.jsx",["339","340","341","342","343","344","345","346","347","348","349"],[],"/*\nAx.jsx 예제를 기반으로 한 마우스 호버 애니메이션입니다.\n이 컴포넌트는 정적인 몸체와 애니메이션되는 날개를 가진 저울을 렌더링합니다.\n*/\n\nimport React, { useRef, useMemo, useState } from 'react';\nimport { useGLTF } from '@react-three/drei';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { RigidBody, CuboidCollider } from '@react-three/rapier';\n\nexport default function Scale({\n  bodyProps = { position: [0, 0, 0], scale: 1, rotation: [0, 0, 0] },\n  wingsLeftProps = { position: [-0.38, 0.2, 0], scale: 1, rotation: [0, 0, 0] },\n  wingsRightProps = { position: [0.38, 0.2, 0], scale: 1, rotation: [0, 0, 0] },\n  wingsLeftPrimitiveOffset = [0, 0, 0],\n  wingsRightPrimitiveOffset = [0, 0, 0],\n  tiltAngle = 0,\n  tiltAngleLeft = Math.PI / 18,\n  tiltAngleRight = Math.PI / 18,\n  animationSpeedLeft = 0.08,\n  animationSpeedRight = 0.08,\n  verticalMovementFactorLeft = 0.05,\n  verticalMovementFactorRight = 0.05,\n}) {\n  const groupRef = useRef();\n  const wingsLeftGroupRef = useRef();\n  const wingsRightGroupRef = useRef();\n\n  const [isHoveredLeft, setIsHoveredLeft] = useState(false);\n  const [isHoveredRight, setIsHoveredRight] = useState(false);\n\n  const { scene: bodySceneOriginal } = useGLTF('/Body.gltf');\n  const { scene: wingsLeftSceneOriginal } = useGLTF('/Wings left.gltf');\n  const { scene: wingsRightSceneOriginal } = useGLTF('/Wings right.gltf');\n\n  const bodyScene = useMemo(() => bodySceneOriginal.clone(true), [bodySceneOriginal]);\n  const wingsLeftScene = useMemo(() => wingsLeftSceneOriginal.clone(true), [wingsLeftSceneOriginal]);\n  const wingsRightScene = useMemo(() => wingsRightSceneOriginal.clone(true), [wingsRightSceneOriginal]);\n\n  const bodyColliderArgs = [0.5, 0.75, 0.5];\n  const wingColliderArgs = [0.7, 0.1, 0.5];\n\n  // 슬라이더 값에 따른 날개 Y 위치 계산\n  const maxVerticalMovement = 0.3; // 최대 수직 이동 거리\n  const leftWingYOffset = tiltAngle * maxVerticalMovement; // tiltAngle이 음수면 왼쪽이 아래로\n  const rightWingYOffset = -tiltAngle * maxVerticalMovement; // tiltAngle이 양수면 오른쪽이 아래로\n\n  const adjustedLeftWingsPosition = [\n    wingsLeftProps.position[0], \n    wingsLeftProps.position[1] + leftWingYOffset, \n    wingsLeftProps.position[2]\n  ];\n  \n  const adjustedRightWingsPosition = [\n    wingsRightProps.position[0], \n    wingsRightProps.position[1] + rightWingYOffset, \n    wingsRightProps.position[2]\n  ];\n\n  return (\n    <group\n      ref={groupRef}\n      position={bodyProps.position}\n      scale={bodyProps.scale}\n      rotation={bodyProps.rotation}\n    >\n      <RigidBody \n        type=\"fixed\" \n        colliders={false}\n        name=\"scale-body\"\n      >\n      <primitive object={bodyScene} />\n        <CuboidCollider args={bodyColliderArgs} position={[0, 0, 0]} />\n      </RigidBody>\n\n      <RigidBody \n        type=\"fixed\" \n        colliders={false} \n        position={adjustedLeftWingsPosition}\n        scale={wingsLeftProps.scale}\n        rotation={wingsLeftProps.rotation}\n        name=\"scale-wing-left\"\n        ref={wingsLeftGroupRef}\n      >\n        <primitive object={wingsLeftScene} position={wingsLeftPrimitiveOffset} />\n        <CuboidCollider args={wingColliderArgs} position={[0,0,0]} />\n      </RigidBody>\n\n      <RigidBody \n        type=\"fixed\" \n        colliders={false} \n        position={adjustedRightWingsPosition}\n        scale={wingsRightProps.scale}\n        rotation={wingsRightProps.rotation}\n        name=\"scale-wing-right\"\n        ref={wingsRightGroupRef}\n      >\n        <primitive object={wingsRightScene} position={wingsRightPrimitiveOffset} />\n        <CuboidCollider args={wingColliderArgs} position={[0,0,0]} />\n      </RigidBody>\n    </group>\n  );\n}\n\nuseGLTF.preload('/Body.gltf');\nuseGLTF.preload('/Wings left.gltf');\nuseGLTF.preload('/Wings right.gltf'); ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/Emoji3D.jsx",["350","351","352"],[],"import React, { useMemo, useRef, useState } from 'react';\nimport { useGLTF } from '@react-three/drei';\nimport { RigidBody } from '@react-three/rapier';\nimport { useDrag } from '@use-gesture/react';\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\n\n// Preload models - this helps in reducing initial load time when component mounts\n// It's good practice to list all potential models if known beforehand.\nconst EMOTION_MODEL_PATHS = [\n  '/models/emotion1.gltf',\n  '/models/emotion2.gltf',\n  '/models/emotion3.gltf',\n  '/models/emotion4.gltf',\n  '/models/emotion5.gltf',\n];\nEMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\nfunction Emoji3D({ modelPath, initialPosition = [0, 0, 0], scale = 0.5, onClick, onDrop, emojiId, draggable = true }) {\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = useMemo(() => scene.clone(true), [scene]);\n  const rigidBodyRef = useRef();\n  const [isDragging, setIsDragging] = useState(false);\n  const { size, viewport, camera } = useThree();\n  const aspect = size.width / size.height;\n\n  const bind = useDrag(({ active, movement: [mx, my], event, first, last, memo }) => {\n    if (!draggable) return;\n    \n    if (first) {\n      console.log('🖱️ 드래그 시작:', emojiId);\n    }\n    \n    setIsDragging(active);\n    \n    if (active && rigidBodyRef.current) {\n      // 첫 드래그 시 초기 위치와 마우스 위치 저장\n      if (first) {\n        const currentPos = rigidBodyRef.current.translation();\n        memo = { \n          initialX: currentPos.x, \n          initialY: currentPos.y, \n          initialZ: currentPos.z\n        };\n      }\n\n      // 감도 조정 - 더 자연스러운 드래그를 위해 증가\n      const scale = viewport.width / size.width * 0.02;\n      \n      const newX = memo.initialX + mx * scale;\n      const newY = memo.initialY - my * scale; // Y축 반전\n      const newZ = memo.initialZ; // Z축 고정\n\n      rigidBodyRef.current.setNextKinematicTranslation({ x: newX, y: newY, z: newZ });\n\n    } else if (last && onDrop && isDragging) {\n        if (rigidBodyRef.current) {\n            const finalPosition = rigidBodyRef.current.translation();\n            console.log('🎯 드래그 종료:', emojiId, 'at', finalPosition);\n            console.log('📍 저울 영역 참고: 왼쪽 날개 [-0.4~0, 0.1~0.3], 오른쪽 날개 [0~0.4, 0.1~0.3]');\n            onDrop(emojiId, finalPosition); \n        }\n        setIsDragging(false);\n    }\n    \n    return memo;\n  }, {\n    enabled: draggable,\n  });\n\n  const handleClick = (event) => {\n    console.log('🎯 클릭:', emojiId, 'draggable:', draggable);\n    event.stopPropagation();\n    if (onClick && !isDragging && draggable) {\n      console.log('✅ 클릭 핸들러 실행:', emojiId);\n      onClick();\n    }\n  };\n\n  return (\n    <RigidBody\n      {...(draggable ? bind() : {})}\n      ref={rigidBodyRef}\n      type={draggable ? \"kinematicPosition\" : \"fixed\"}\n      position={initialPosition}\n      colliders=\"cuboid\"\n      scale={Array.isArray(scale) ? scale : [scale, scale, scale]}\n      onClick={handleClick} \n      name={`emoji-${emojiId}`} \n    >\n      <primitive \n        object={clonedScene} \n        scale={[1,1,1]} // Scale is handled by RigidBody\n      />\n    </RigidBody>\n  );\n}\n\nexport default Emoji3D; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/EmojiSelector3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/EmotionColumn.jsx",["353"],[],"import React from 'react';\n\nfunction EmotionColumn({ emoji = '😀', keywords = [], sliderValue = 50, onSliderChange }) {\n  return (\n    <div style={{\n      width: 260,\n      minWidth: 220,\n      minHeight: '100vh',\n      background: '#B02B3A',\n      borderRadius: 30,\n      padding: '24px 12px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      gap: 24,\n      boxShadow: '0 2px 12px rgba(0,0,0,0.08)'\n    }}>\n      <div style={{\n        width: '100%',\n        background: '#D2F2E9',\n        color: '#222',\n        fontWeight: 700,\n        fontSize: 22,\n        borderRadius: 12,\n        textAlign: 'center',\n        padding: '10px 0',\n        marginTop: 22, \n        marginBottom: 1\n      }}>감정 무게</div>\n      <div style={{\n        width: '90%',\n        background: 'white',\n        borderRadius: 18,\n        boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        padding: '18px 0 18px 0',\n        marginBottom: 30\n      }}>\n        <div style={{ fontSize: 60, marginBottom: 10 }}>{emoji}</div>\n        <div style={{ width: '80%', height: 18, background: '#BFE2D6', borderRadius: 9, position: 'relative', margin: '10px 0' }}>\n          <div style={{\n            position: 'absolute',\n            left: `calc(${sliderValue}% - 18px)`,\n            top: -7,\n            width: 32,\n            height: 32,\n            background: '#E94B5A',\n            borderRadius: '50%',\n            boxShadow: '0 2px 6px rgba(0,0,0,0.13)',\n            border: '3px solid #fff',\n            transition: 'left 0.2s'\n          }} />\n        </div>\n      </div>\n      <div style={{\n        width: '90%',\n        background: 'white',\n        borderRadius: 18,\n        boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n        padding: '16px 10px',\n        marginBottom: 8,\n        fontSize: 18,\n        color: '#222',\n        textAlign: 'left',\n        minHeight: 90,\n        display: 'flex',\n        flexDirection: 'column',\n        gap: 4\n      }}>\n        <div style={{ fontWeight: 700, fontSize: 18, marginBottom: 6 }}>감정 배워보기</div>\n        <div>\n          {keywords.map((k, i) => (\n            <span key={i} style={{ marginRight: 8 }}>{k}</span>\n          ))}\n        </div>\n      </div>\n      <div style={{ flex: 1 }} />\n      <button\n        style={{\n          width: '90%',\n          background: 'white',\n          color: '#B02B3A',\n          border: 'none',\n          borderRadius: 18,\n          fontWeight: 700,\n          fontSize: 20,\n          padding: '12px 0',\n          marginTop: 'auto',\n          marginBottom: 40,\n          boxShadow: '0 2px 8px rgba(0,0,0,0.07)',\n          cursor: 'pointer'\n        }}\n      >만들기 시작</button>\n    </div>\n  );\n}\n\nexport default EmotionColumn; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/FallingModels.jsx",["354"],[],"import React, { useState, useRef, useMemo } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\n\nconst EMOTION_MODEL_PATHS = [\n  '/models/emotion1.gltf',\n  '/models/emotion2.gltf',\n  '/models/emotion3.gltf',\n  '/models/emotion4.gltf',\n  '/models/emotion5.gltf',\n];\nconst NUM_FALLING_MODELS = 100;\nconst FALLING_MODEL_SCALE = 40;\n\nEMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\nfunction FallingEmotionModel({ modelPath, initialX, initialY, viewportHeight, modelScale }) {\n  const ref = React.useRef();\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = React.useMemo(() => scene.clone(), [scene]);\n  \n  const [isHovered, setIsHovered] = useState(false);\n  const velocity = useRef({ x: 0, y: 0 });\n  const [rotationSpeed] = useState(() => (Math.random() - 0.5) * 0.02);\n  const [xPos] = useState(initialX);\n\n  useFrame((state, delta) => {\n    if (ref.current) {\n      const currentVel = velocity.current;\n      const G_ACCEL = 0.0003;\n      const HOVER_SIDE_STRENGTH = 0.15;\n      const HOVER_UP_STRENGTH = 0.0008;\n      const X_DAMPING = 0.92;\n\n      currentVel.y += G_ACCEL * 80 * delta;\n\n      if (isHovered) {\n        currentVel.x += (Math.random() - 0.5) * HOVER_SIDE_STRENGTH * 60 * delta;\n        currentVel.y -= HOVER_UP_STRENGTH * 60 * delta;\n      }\n\n      ref.current.position.x += currentVel.x * 60 * delta;\n      ref.current.position.y -= currentVel.y * 60 * delta;\n      currentVel.x *= X_DAMPING;\n\n      ref.current.rotation.y += rotationSpeed * 60 * delta;\n      ref.current.rotation.x += rotationSpeed * 0.5 * 60 * delta;\n\n      if (ref.current.position.y < -viewportHeight / 2 - modelScale * 2) {\n        ref.current.position.y = viewportHeight / 2 + modelScale * 2 + Math.random() * viewportHeight * 0.3;\n        ref.current.position.x = (Math.random() - 0.5) * state.viewport.width * 0.9;\n        currentVel.x = 0;\n        currentVel.y = 0;\n        setIsHovered(false);\n      }\n    }\n  });\n\n  return (\n    <primitive\n      ref={ref}\n      object={clonedScene}\n      scale={modelScale}\n      position={[xPos, initialY, 0]}\n      onPointerOver={(event) => { \n        event.stopPropagation(); \n        setIsHovered(true); \n      }}\n      onPointerOut={() => setIsHovered(false)}\n    />\n  );\n}\n\nexport function FallingModelsScene() {\n  const { viewport } = useThree();\n  const models = [];\n\n  for (let i = 0; i < NUM_FALLING_MODELS; i++) {\n    const modelPath = EMOTION_MODEL_PATHS[i % EMOTION_MODEL_PATHS.length];\n    const initialModelX = (Math.random() - 0.5) * viewport.width * 1.2;\n    const initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + (i % (NUM_FALLING_MODELS / 5)) * (FALLING_MODEL_SCALE * 1.8) + Math.random() * FALLING_MODEL_SCALE;\n\n    models.push(\n      <FallingEmotionModel\n        key={`${modelPath}-${i}`}\n        modelPath={modelPath}\n        initialX={initialModelX}\n        initialY={initialModelY}\n        viewportHeight={viewport.height}\n        modelScale={FALLING_MODEL_SCALE}\n      />\n    );\n  }\n\n  return (\n    <>\n      <ambientLight intensity={0.7} />\n      <directionalLight position={[0, 10, 10]} intensity={1} />\n      <directionalLight position={[0, -10, -5]} intensity={0.3} />\n      {models}\n    </>\n  );\n} ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/FullScreenContainer.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/GameModal.jsx",["355"],[],"import React from 'react';\nimport { emojiKeywords } from './constants';\n// import { emojiKeywords } from './constants'; //This will be used once constants.js is created\n\nconst GameModal = ({ isOpen, emoji, onClose }) => {\n  const [currentKeywordInput, setCurrentKeywordInput] = React.useState('');\n  const [userKeywords, setUserKeywords] = React.useState([]);\n\n  React.useEffect(() => {\n    if (isOpen) {\n      setCurrentKeywordInput('');\n      setUserKeywords([]);\n    } else {\n      setCurrentKeywordInput('');\n      setUserKeywords([]);\n    }\n  }, [isOpen, emoji]); \n\n  if (!isOpen || !emoji) return null;\n\n  const handleAddKeyword = () => {\n    if (currentKeywordInput.trim() !== '') {\n      setUserKeywords(prev => [...prev, currentKeywordInput.trim()]);\n      setCurrentKeywordInput('');\n    }\n  };\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: '48%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      width: '60vw',\n      height: 'auto',\n      minHeight: '40vh',\n      maxHeight: '70vh',\n      overflowY: 'auto',\n      maxWidth: '600px',\n      backgroundColor: 'rgba(255, 255, 255, 0.90)',\n      border: '2px solid #eee',\n      borderRadius: '10px',\n      boxShadow: '0 8px 13px rgba(0, 0, 0, 0.71)',\n      padding: '30px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      gap: '15px',\n      zIndex: 1000,\n    }}>\n      <span style={{ fontSize: '100px', marginBottom: '0px' }}>{emoji}</span>\n      <h2 style={{ textAlign: 'center', marginTop: '0px', marginBottom: '10px', fontSize: '22px' }}>나의 감정 키워드</h2>\n      \n      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', width: '90%', marginBottom:'10px' }}>\n        <input \n          type=\"text\"\n          value={currentKeywordInput}\n          onChange={(e) => setCurrentKeywordInput(e.target.value)}\n          placeholder=\"키워드 입력\"\n          style={{\n            flexGrow: 1,\n            padding: '10px 15px',\n            fontSize: '16px',\n            borderRadius: '5px',\n            border: '1px solid #ccc',\n            boxSizing: 'border-box'\n          }}\n          onKeyPress={(e) => {\n            if (e.key === 'Enter') {\n              handleAddKeyword();\n            }\n          }}\n        />\n        <button onClick={handleAddKeyword} style={{\n          padding: '10px 15px',\n          fontSize: '16px',\n          cursor: 'pointer',\n          background: '#5cb85c',\n          color: 'white',\n          border: 'none',\n          borderRadius: '5px'\n        }}>\n          추가\n        </button>\n      </div>\n\n      <div style={{ \n        display: 'flex', \n        flexWrap: 'wrap', \n        gap: '8px', \n        justifyContent: 'center', \n        width: '100%', \n        padding: '10px 0', \n        minHeight: '50px' \n      }}>\n        {userKeywords.length > 0 ? userKeywords.map((keyword, index) => (\n          <span key={index} style={{\n            padding: '8px 15px',\n            background: '#ffc0cb',\n            borderRadius: '30px',\n            fontSize: '18px'\n          }}>\n            {keyword}\n          </span>\n        )) : (\n          <span style={{color: '#888', fontSize: '16px'}}>입력한 키워드가 여기에 표시됩니다.</span>\n        )}\n      </div>\n      <button onClick={onClose} style={{\n        marginTop: 'auto',\n        padding: '10px 20px',\n        fontSize: '16px',\n        cursor: 'pointer',\n        background: '#007bff',\n        color: 'white',\n        border: 'none',\n        borderRadius: '5px'\n      }}>\n        닫기\n      </button>\n    </div>\n  );\n};\n\nexport default GameModal; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/IconBarPlaceholder.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/ScaledScene.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/TextInputModal.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v1/constants.js",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/EmotionColumn.jsx",["356"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/FallingModels.jsx",["357"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/FullScreenContainer.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/GameModal.jsx",["358"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/IconBarPlaceholder.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/ScaledScene.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/TextInputModal.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v2/constants.js",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/Emoji3D.jsx",["359","360","361","362","363"],[],"import React, { useMemo, useRef, useState } from 'react';\nimport { useGLTF } from '@react-three/drei';\nimport { RigidBody } from '@react-three/rapier';\nimport { useDrag } from '@use-gesture/react';\nimport { useThree } from '@react-three/fiber';\nimport * as THREE from 'three';\n\n// Preload models - this helps in reducing initial load time when component mounts\n// It's good practice to list all potential models if known beforehand.\nconst EMOTION_MODEL_PATHS = [\n  '/models/emotion1.gltf',\n  '/models/emotion2.gltf',\n  '/models/emotion3.gltf',\n  '/models/emotion4.gltf',\n  '/models/emotion5.gltf',\n];\nEMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\nfunction Emoji3D({ modelPath, initialPosition = [0, 0, 0], scale = 0.5, onClick, onDrop, emojiId, draggable = true }) {\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = useMemo(() => scene.clone(true), [scene]);\n  const rigidBodyRef = useRef();\n  const [isDragging, setIsDragging] = useState(false);\n  const { size, viewport, camera } = useThree();\n  const aspect = size.width / size.height;\n\n  const bind = useDrag(({ active, movement: [mx, my], event, first, last, memo }) => {\n    if (!draggable) return;\n    setIsDragging(active);\n    if (active && rigidBodyRef.current) {\n      let previousPosition;\n      if (first) { // On drag start\n        // memo will store the initial world position of the object\n        const currentRigidBodyPos = rigidBodyRef.current.translation();\n        previousPosition = new THREE.Vector3(currentRigidBodyPos.x, currentRigidBodyPos.y, currentRigidBodyPos.z);\n      } else {\n        previousPosition = memo;\n      }\n\n      // Project mouse position to a plane at the object's Z depth\n      const mousePlanePos = new THREE.Vector3();\n      mousePlanePos.set(\n        (event.clientX / size.width) * 2 - 1,\n        -(event.clientY / size.height) * 2 + 1,\n        0.5 // NDC Z coordinate\n      );\n      mousePlanePos.unproject(camera);\n      const dir = mousePlanePos.sub(camera.position).normalize();\n      const distance = (previousPosition.z - camera.position.z) / dir.z;\n      const newWorldPos = camera.position.clone().add(dir.multiplyScalar(distance));\n      \n      // Calculate the delta from the initial drag point in world space\n      // This requires knowing the initial point where drag started in world space\n      // and the current mouse point in world space.\n      \n      // For simplicity, let's try a simpler delta based on screen movement for now,\n      // and refine if this isn't smooth enough.\n      // The viewport.width / size.width gives a factor to convert screen pixels to world units at z=0.\n      // We need to adjust this for the object's actual depth.\n      const factor = (viewport.width / size.width) * (previousPosition.z / camera.near); // Approximate adjustment for depth\n      // A more robust solution might involve projecting the initial and current mouse points\n      // to the object's Z plane and calculating the world-space delta there.\n\n      // If this is the first drag event, memoize the initial position\n      if (first) {\n         memo = rigidBodyRef.current.translation();\n      }\n\n      // Calculate new position based on initial position (memo) and screen delta (mx, my)\n      // This translation needs to be relative to the camera's orientation if it's not fixed\n      // For a fixed camera, we can map screen dx/dy to world dx/dy\n      const worldDx = mx * (viewport.width / size.width);\n      const worldDy = -my * (viewport.height / size.height); // Y is inverted\n      \n      // We need to find the initial world position (memo) and add worldDx, worldDy\n      // This is still not perfect as it doesn't account for camera perspective fully.\n      // A common approach: map screen coords to a plane intersecting the object.\n      \n      // Let's use the setNextKinematicTranslation with a calculated new position\n      // The current `pos` from unprojection is where the mouse *is* on the plane,\n      // not the delta. We need to apply the *movement* (mx, my).\n\n      // On the first frame of drag, record the initial position in `memo`\n      if (first) {\n        const currentPosVec = rigidBodyRef.current.translation();\n        memo = { x: currentPosVec.x, y: currentPosVec.y, z: currentPosVec.z, screenX: event.clientX, screenY: event.clientY };\n      }\n\n      // Calculate the change in screen coordinates\n      const screenDeltaX = event.clientX - memo.screenX;\n      const screenDeltaY = event.clientY - memo.screenY;\n\n      // Convert screen delta to world delta at the object's depth\n      // This requires knowing the size of a pixel in world units at that depth\n      // This is a simplification and might need adjustment based on camera FOV / type\n      const worldUnitsPerPixelX = viewport.width / size.width;\n      const worldUnitsPerPixelY = viewport.height / size.height;\n\n      const newX = memo.x + screenDeltaX * worldUnitsPerPixelX;\n      const newY = memo.y - screenDeltaY * worldUnitsPerPixelY; // Screen Y is often inverted in 3D\n\n      rigidBodyRef.current.setNextKinematicTranslation({ x: newX, y: newY, z: memo.z });\n\n    } else if (last && onDrop && isDragging) { // Drag ended (use `last` from useDrag)\n        if (rigidBodyRef.current) {\n            const finalPosition = rigidBodyRef.current.translation();\n            onDrop(emojiId, finalPosition); \n        }\n        setIsDragging(false); // Reset dragging state\n    }\n    return memo;\n  }, {\n    enabled: draggable,\n  });\n\n  const handleClick = (event) => {\n    event.stopPropagation();\n    if (onClick && !isDragging && draggable) {\n      onClick();\n    }\n  };\n\n  return (\n    <RigidBody\n      {...(draggable ? bind() : {})}\n      ref={rigidBodyRef}\n      type={draggable ? \"kinematicPosition\" : \"fixed\"}\n      position={initialPosition}\n      colliders=\"cuboid\"\n      scale={Array.isArray(scale) ? scale : [scale, scale, scale]}\n      onClick={handleClick} \n      name={`emoji-${emojiId}`} \n    >\n      <primitive \n        object={clonedScene} \n        scale={[1,1,1]} // Scale is handled by RigidBody\n      />\n    </RigidBody>\n  );\n}\n\nexport default Emoji3D; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/EmojiSelector3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/EmotionColumn.jsx",["364"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/FallingModels.jsx",["365"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/FullScreenContainer.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/GameModal.jsx",["366"],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/IconBarPlaceholder.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/ScaledScene.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/TextInputModal.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v3/constants.js",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/BasketColliders.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/Emoji3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/EmojiSelector3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/EmotionColumn.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingEmoji3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingEmojiManager.jsx",["367","368","369","370","371"],[],"import React, { useState, useEffect, useRef } from 'react';\nimport { useControls } from 'leva';\nimport FallingEmoji3D from './FallingEmoji3D';\nimport BasketColliders from './BasketColliders';\n\nfunction FallingEmojiManager({ \n  leftCount = 0, \n  rightCount = 0, \n  leftEmojiTypes = [], // 배열로 변경\n  rightEmojiTypes = [], // 배열로 변경\n  onEmojiLanded = null // 이모티콘이 바구니에 도달했을 때 콜백\n}) {\n  const [leftEmojis, setLeftEmojis] = useState([]);\n  const [rightEmojis, setRightEmojis] = useState([]);\n  const emojiIdCounter = useRef(0);\n\n  // useControls를 사용하여 실시간 조정 가능한 값들\n  const {\n    leftBasketX,\n    rightBasketX,\n    basketY,\n    dropHeight,\n    emojiScale,\n    randomXRange,\n    randomZRange,\n    dropDelay\n  } = useControls('Emoji Drop Settings', {\n    leftBasketX: { value: -0.38 * 1.9, min: -3, max: 0, step: 0.01 },\n    rightBasketX: { value: 0.38 * 1.9, min: 0, max: 3, step: 0.01 },\n    basketY: { value: (0.5 + 0.2) * 1.9, min: 0, max: 5, step: 0.01 },\n    dropHeight: { value: 6.3, min: 3, max: 15, step: 0.1 },\n    emojiScale: { value: 0.99, min: 0.1, max: 2, step: 0.01 },\n    randomXRange: { value: 0.05, min: 0, max: 0.5, step: 0.01 },\n    randomZRange: { value: 0.02, min: 0, max: 0.5, step: 0.01 },\n    dropDelay: { value: 200, min: 50, max: 1000, step: 10 }\n  });\n\n  // 시각적 디버깅을 위한 바구니 위치 표시 컨트롤\n  const { showBasketHelpers } = useControls('Debug Helpers', {\n    showBasketHelpers: { value: true }\n  });\n\n  // 이모티콘이 바구니에 도달했을 때 처리하는 함수\n  const handleEmojiLanded = (landedInfo) => {\n    const { emojiType, basket, position } = landedInfo;\n    \n    // 상위 컴포넌트에 알림\n    if (onEmojiLanded) {\n      onEmojiLanded(landedInfo);\n    }\n\n    // 해당 이모티콘을 상태에서 제거 (약간의 지연 후)\n    setTimeout(() => {\n      if (basket === 'left') {\n        setLeftEmojis(prev => prev.slice(1)); // 첫 번째 이모티콘 제거\n      } else if (basket === 'right') {\n        setRightEmojis(prev => prev.slice(1)); // 첫 번째 이모티콘 제거\n      }\n    }, 1500); // 사라짐 애니메이션이 완료된 후 제거\n  };\n\n  // 좌측 이모티콘 개수 변화 감지\n  useEffect(() => {\n    const currentLeftCount = leftEmojis.length;\n    \n    if (leftCount > currentLeftCount && leftEmojiTypes.length > 0) {\n      // 이모티콘 추가 - 하나씩 떨어뜨리기\n      const newEmojis = [];\n      for (let i = currentLeftCount; i < leftCount; i++) {\n        const emojiId = emojiIdCounter.current++;\n        // 바구니 중앙에 정확히 떨어지도록 랜덤 범위 조정 가능\n        const randomX = leftBasketX + (Math.random() - 0.5) * randomXRange;\n        const randomZ = (Math.random() - 0.5) * randomZRange;\n        const delay = (i - currentLeftCount) * dropDelay;\n        \n        // 랜덤하게 이모티콘 타입 선택\n        const randomEmojiType = leftEmojiTypes[Math.floor(Math.random() * leftEmojiTypes.length)];\n        \n        setTimeout(() => {\n          setLeftEmojis(prev => [...prev, {\n            id: emojiId,\n            position: [randomX, dropHeight, randomZ],\n            type: randomEmojiType\n          }]);\n        }, delay);\n      }\n    } else if (leftCount < currentLeftCount) {\n      // 이모티콘 제거\n      setLeftEmojis(prev => prev.slice(0, leftCount));\n    }\n  }, [leftCount, leftEmojiTypes, leftBasketX, dropHeight, randomXRange, randomZRange, dropDelay]);\n\n  // 우측 이모티콘 개수 변화 감지\n  useEffect(() => {\n    const currentRightCount = rightEmojis.length;\n    \n    if (rightCount > currentRightCount && rightEmojiTypes.length > 0) {\n      // 이모티콘 추가 - 하나씩 떨어뜨리기\n      for (let i = currentRightCount; i < rightCount; i++) {\n        const emojiId = emojiIdCounter.current++;\n        // 바구니 중앙에 정확히 떨어지도록 랜덤 범위 조정 가능\n        const randomX = rightBasketX + (Math.random() - 0.5) * randomXRange;\n        const randomZ = (Math.random() - 0.5) * randomZRange;\n        const delay = (i - currentRightCount) * dropDelay;\n        \n        // 랜덤하게 이모티콘 타입 선택\n        const randomEmojiType = rightEmojiTypes[Math.floor(Math.random() * rightEmojiTypes.length)];\n        \n        setTimeout(() => {\n          setRightEmojis(prev => [...prev, {\n            id: emojiId,\n            position: [randomX, dropHeight, randomZ],\n            type: randomEmojiType\n          }]);\n        }, delay);\n      }\n    } else if (rightCount < currentRightCount) {\n      // 이모티콘 제거\n      setRightEmojis(prev => prev.slice(0, rightCount));\n    }\n  }, [rightCount, rightEmojiTypes, rightBasketX, dropHeight, randomXRange, randomZRange, dropDelay]);\n\n  return (\n    <group>\n      {/* 바구니 충돌체 */}\n      <BasketColliders />\n      \n      {/* 시각적 디버깅 헬퍼: 바구니 위치 표시 */}\n      {showBasketHelpers && (\n        <>\n          {/* 좌측 바구니 위치 표시 */}\n          <mesh position={[leftBasketX, basketY, 0]}>\n            <cylinderGeometry args={[0.4, 0.4, 0.1]} />\n            <meshBasicMaterial color=\"red\" transparent opacity={0.3} />\n          </mesh>\n          <mesh position={[leftBasketX, dropHeight, 0]}>\n            <sphereGeometry args={[0.1]} />\n            <meshBasicMaterial color=\"yellow\" />\n          </mesh>\n          \n          {/* 우측 바구니 위치 표시 */}\n          <mesh position={[rightBasketX, basketY, 0]}>\n            <cylinderGeometry args={[0.4, 0.4, 0.1]} />\n            <meshBasicMaterial color=\"blue\" transparent opacity={0.3} />\n          </mesh>\n          <mesh position={[rightBasketX, dropHeight, 0]}>\n            <sphereGeometry args={[0.1]} />\n            <meshBasicMaterial color=\"yellow\" />\n          </mesh>\n        </>\n      )}\n      \n      {/* 좌측 떨어지는 이모티콘들 */}\n      {leftEmojis.map((emoji) => (\n        <FallingEmoji3D\n          key={`left-${emoji.id}`}\n          startPosition={emoji.position}\n          scale={emojiScale}\n          emojiType={emoji.type}\n          onLanded={handleEmojiLanded}\n        />\n      ))}\n      \n      {/* 우측 떨어지는 이모티콘들 */}\n      {rightEmojis.map((emoji) => (\n        <FallingEmoji3D\n          key={`right-${emoji.id}`}\n          startPosition={emoji.position}\n          scale={emojiScale}\n          emojiType={emoji.type}\n          onLanded={handleEmojiLanded}\n        />\n      ))}\n    </group>\n  );\n}\n\nexport default FallingEmojiManager; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingModels.jsx",["372"],[],"import React, { useState, useRef, useMemo } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\n\nconst EMOTION_MODEL_PATHS = [\n  '/models/emotion1.gltf',\n  '/models/emotion2.gltf',\n  '/models/emotion3.gltf',\n  '/models/emotion4.gltf',\n  '/models/emotion5.gltf',\n];\nconst NUM_FALLING_MODELS = 100;\nconst FALLING_MODEL_SCALE = 40;\n\nEMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\nfunction FallingEmotionModel({ modelPath, initialX, initialY, viewportHeight, modelScale, delay = 0 }) {\n  const ref = React.useRef();\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = React.useMemo(() => scene.clone(), [scene]);\n  \n  const [isHovered, setIsHovered] = useState(false);\n  const [isVisible, setIsVisible] = useState(delay === 0);\n  const velocity = useRef({ x: 0, y: 0 });\n  const [rotationSpeed] = useState(() => (Math.random() - 0.5) * 0.02);\n  const [xPos] = useState(initialX);\n  const startTime = useRef(Date.now());\n\n  useFrame((state, delta) => {\n    // 지연 시간 처리\n    if (!isVisible && Date.now() - startTime.current > delay) {\n      setIsVisible(true);\n    }\n\n    if (ref.current && isVisible) {\n      const currentVel = velocity.current;\n      const G_ACCEL = 0.0003;\n      const HOVER_SIDE_STRENGTH = 0.15;\n      const HOVER_UP_STRENGTH = 0.0008;\n      const X_DAMPING = 0.92;\n\n      currentVel.y += G_ACCEL * 80 * delta;\n\n      if (isHovered) {\n        currentVel.x += (Math.random() - 0.5) * HOVER_SIDE_STRENGTH * 60 * delta;\n        currentVel.y -= HOVER_UP_STRENGTH * 60 * delta;\n      }\n\n      ref.current.position.x += currentVel.x * 60 * delta;\n      ref.current.position.y -= currentVel.y * 60 * delta;\n      currentVel.x *= X_DAMPING;\n\n      ref.current.rotation.y += rotationSpeed * 60 * delta;\n      ref.current.rotation.x += rotationSpeed * 0.5 * 60 * delta;\n\n      if (ref.current.position.y < -viewportHeight / 2 - modelScale * 2) {\n        ref.current.position.y = state.viewport.height / 2 + modelScale * 2 + Math.random() * viewportHeight * 0.3;\n        ref.current.position.x = (Math.random() - 0.5) * state.viewport.width * 0.9;\n        currentVel.x = 0;\n        currentVel.y = 0;\n        setIsHovered(false);\n      }\n    }\n  });\n\n  if (!isVisible) return null;\n\n  return (\n    <primitive\n      ref={ref}\n      object={clonedScene}\n      scale={modelScale}\n      position={[xPos, initialY, 0]}\n      onPointerOver={(event) => { \n        event.stopPropagation(); \n        setIsHovered(true); \n      }}\n      onPointerOut={() => setIsHovered(false)}\n    />\n  );\n}\n\nexport function FallingModelsScene() {\n  const { viewport } = useThree();\n  const models = [];\n\n  for (let i = 0; i < NUM_FALLING_MODELS; i++) {\n    const modelPath = EMOTION_MODEL_PATHS[i % EMOTION_MODEL_PATHS.length];\n    const initialModelX = (Math.random() - 0.5) * viewport.width * 1.2;\n    \n    // 즉시 떨어지는 이모티콘들 (30%)\n    let initialModelY, delay;\n    if (i < NUM_FALLING_MODELS * 0.3) {\n      // 즉시 화면에 보이는 이모티콘들 - 화면 중간~위쪽에서 시작\n      initialModelY = (Math.random() * viewport.height * 0.8) + (viewport.height * 0.1);\n      delay = 0;\n    } else if (i < NUM_FALLING_MODELS * 0.7) {\n      // 중간에 많이 떨어지는 이모티콘들 (40%)\n      initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + Math.random() * FALLING_MODEL_SCALE;\n      delay = Math.random() * 2000 + 1000; // 1-3초 후 시작\n    } else {\n      // 나머지 이모티콘들 (30%)\n      initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + Math.random() * FALLING_MODEL_SCALE;\n      delay = Math.random() * 4000 + 3000; // 3-7초 후 시작\n    }\n\n    models.push(\n      <FallingEmotionModel\n        key={`${modelPath}-${i}`}\n        modelPath={modelPath}\n        initialX={initialModelX}\n        initialY={initialModelY}\n        viewportHeight={viewport.height}\n        modelScale={FALLING_MODEL_SCALE}\n        delay={delay}\n      />\n    );\n  }\n\n  return (\n    <>\n      <ambientLight intensity={0.7} />\n      <directionalLight position={[0, 10, 10]} intensity={1} />\n      <directionalLight position={[0, -10, -5]} intensity={0.3} />\n      {models}\n    </>\n  );\n} ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FallingSelectedEmojiScene.jsx",["373"],[],"import React, { useState, useRef, useMemo } from 'react';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\n\nconst NUM_FALLING_MODELS = 100;\nconst FALLING_MODEL_SCALE = 40;\n\n// 이모티콘 문자를 모델 경로로 매핑\nconst getModelPath = (emojiType) => {\n  const emojiToModel = {\n    '😀': '/models/emotion1.gltf', // joy\n    '😮': '/models/emotion2.gltf', // surprise\n    '😐': '/models/emotion3.gltf', // neutral\n    '😖': '/models/emotion4.gltf', // sadness\n    '😠': '/models/emotion5.gltf', // anger\n  };\n  \n  return emojiToModel[emojiType] || '/models/emotion1.gltf';\n};\n\n// 모든 모델 프리로드\nconst EMOTION_MODEL_PATHS = [\n  '/models/emotion1.gltf',\n  '/models/emotion2.gltf',\n  '/models/emotion3.gltf',\n  '/models/emotion4.gltf',\n  '/models/emotion5.gltf',\n];\nEMOTION_MODEL_PATHS.forEach(path => useGLTF.preload(path));\n\nfunction FallingEmotionModel({ modelPath, initialX, initialY, viewportHeight, modelScale, delay = 0 }) {\n  const ref = React.useRef();\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = React.useMemo(() => scene.clone(), [scene]);\n  \n  const [isHovered, setIsHovered] = useState(false);\n  const [isVisible, setIsVisible] = useState(delay === 0);\n  const velocity = useRef({ x: 0, y: 0 });\n  const [rotationSpeed] = useState(() => (Math.random() - 0.5) * 0.02);\n  const [xPos] = useState(initialX);\n  const startTime = useRef(Date.now());\n\n  useFrame((state, delta) => {\n    // 지연 시간 처리\n    if (!isVisible && Date.now() - startTime.current > delay) {\n      setIsVisible(true);\n    }\n\n    if (ref.current && isVisible) {\n      const currentVel = velocity.current;\n      const G_ACCEL = 0.0003;\n      const HOVER_SIDE_STRENGTH = 0.15;\n      const HOVER_UP_STRENGTH = 0.0008;\n      const X_DAMPING = 0.92;\n\n      currentVel.y += G_ACCEL * 80 * delta;\n\n      if (isHovered) {\n        currentVel.x += (Math.random() - 0.5) * HOVER_SIDE_STRENGTH * 60 * delta;\n        currentVel.y -= HOVER_UP_STRENGTH * 60 * delta;\n      }\n\n      ref.current.position.x += currentVel.x * 60 * delta;\n      ref.current.position.y -= currentVel.y * 60 * delta;\n      currentVel.x *= X_DAMPING;\n\n      ref.current.rotation.y += rotationSpeed * 60 * delta;\n      ref.current.rotation.x += rotationSpeed * 0.5 * 60 * delta;\n\n      if (ref.current.position.y < -viewportHeight / 2 - modelScale * 2) {\n        ref.current.position.y = viewportHeight / 2 + modelScale * 2 + Math.random() * viewportHeight * 0.3;\n        ref.current.position.x = (Math.random() - 0.5) * state.viewport.width * 0.9;\n        currentVel.x = 0;\n        currentVel.y = 0;\n        setIsHovered(false);\n      }\n    }\n  });\n\n  if (!isVisible) return null;\n\n  return (\n    <primitive\n      ref={ref}\n      object={clonedScene}\n      scale={modelScale}\n      position={[xPos, initialY, 0]}\n      onPointerOver={(event) => { \n        event.stopPropagation(); \n        setIsHovered(true); \n      }}\n      onPointerOut={() => setIsHovered(false)}\n    />\n  );\n}\n\nexport function FallingSelectedEmojiScene({ dominantEmojis = [] }) {\n  const { viewport } = useThree();\n  const models = [];\n  \n  // 선택된 이모티콘들의 모델 경로들 가져오기\n  const selectedModelPaths = dominantEmojis.length > 0 \n    ? dominantEmojis.map(emoji => getModelPath(emoji))\n    : ['/models/emotion1.gltf']; // 기본값\n\n  for (let i = 0; i < NUM_FALLING_MODELS; i++) {\n    const initialModelX = (Math.random() - 0.5) * viewport.width * 1.2;\n    \n    // 랜덤하게 모델 경로 선택\n    const randomModelPath = selectedModelPaths[Math.floor(Math.random() * selectedModelPaths.length)];\n    \n    // 즉시 떨어지는 이모티콘들 (30%)\n    let initialModelY, delay;\n    if (i < NUM_FALLING_MODELS * 0.3) {\n      // 즉시 화면에 보이는 이모티콘들 - 화면 중간~위쪽에서 시작\n      initialModelY = (Math.random() * viewport.height * 0.8) + (viewport.height * 0.1);\n      delay = 0;\n    } else if (i < NUM_FALLING_MODELS * 0.7) {\n      // 중간에 많이 떨어지는 이모티콘들 (40%)\n      initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + Math.random() * FALLING_MODEL_SCALE;\n      delay = Math.random() * 2000 + 1000; // 1-3초 후 시작\n    } else {\n      // 나머지 이모티콘들 (30%)\n      initialModelY = viewport.height / 2 + FALLING_MODEL_SCALE + Math.random() * FALLING_MODEL_SCALE;\n      delay = Math.random() * 4000 + 3000; // 3-7초 후 시작\n    }\n\n    models.push(\n      <FallingEmotionModel\n        key={`${randomModelPath}-${i}`}\n        modelPath={randomModelPath}\n        initialX={initialModelX}\n        initialY={initialModelY}\n        viewportHeight={viewport.height}\n        modelScale={FALLING_MODEL_SCALE}\n        delay={delay}\n      />\n    );\n  }\n\n  return (\n    <>\n      <ambientLight intensity={0.7} />\n      <directionalLight position={[0, 10, 10]} intensity={1} />\n      <directionalLight position={[0, -10, -5]} intensity={0.3} />\n      {models}\n    </>\n  );\n} ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/FullScreenContainer.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/GameModal.jsx",["374","375"],[],"import React, { useState } from 'react';\nimport { emojiKeywords } from './constants';\n// import { emojiKeywords } from './constants'; //This will be used once constants.js is created\n\nconst GameModal = ({ isOpen, emoji, onClose, onEmojiSelect, onKeywordUpdate, existingKeywords = [] }) => {\n  const [currentKeywordInput, setCurrentKeywordInput] = React.useState('');\n  const [userKeywords, setUserKeywords] = React.useState([]);\n  const [hoveredButton, setHoveredButton] = useState(null);\n\n  React.useEffect(() => {\n    if (isOpen && emoji) {\n      setCurrentKeywordInput('');\n      setUserKeywords(existingKeywords);\n    }\n  }, [isOpen, emoji, existingKeywords]); \n\n  if (!isOpen || !emoji) return null;\n\n  const handleAddKeyword = () => {\n    if (currentKeywordInput.trim() !== '') {\n      const newKeywords = [...userKeywords, currentKeywordInput.trim()];\n      setUserKeywords(newKeywords);\n      setCurrentKeywordInput('');\n      if (onKeywordUpdate) {\n        onKeywordUpdate(emoji, newKeywords);\n      }\n    }\n  };\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: '48%',\n      left: '50%',\n      transform: 'translate(-50%, -50%)',\n      width: '60vw',\n      height: 'auto',\n      minHeight: '40vh',\n      maxHeight: '70vh',\n      overflowY: 'auto',\n      maxWidth: '600px',\n      backgroundColor: 'rgba(255, 255, 255, 0.90)',\n      border: '2px solid #eee',\n      borderRadius: '10px',\n      boxShadow: '0 8px 13px rgba(0, 0, 0, 0.71)',\n      padding: '30px',\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center',\n      gap: '15px',\n      zIndex: 1000,\n    }}>\n      <span style={{ fontSize: '100px', marginBottom: '0px' }}>{emoji}</span>\n      <h2 style={{ textAlign: 'center', marginTop: '0px', marginBottom: '10px', fontSize: '22px' }}>오늘의 감정 이유</h2>\n      \n      <div style={{ display: 'flex', alignItems: 'center', gap: '10px', width: '90%', marginBottom:'10px' }}>\n        <input \n          type=\"text\"\n          value={currentKeywordInput}\n          onChange={(e) => setCurrentKeywordInput(e.target.value)}\n          placeholder=\"선택 이유\"\n          style={{\n            flexGrow: 1,\n            padding: '10px 15px',\n            fontSize: '16px',\n            borderRadius: '5px',\n            border: '1px solid #ccc',\n            boxSizing: 'border-box'\n          }}\n          onKeyPress={(e) => {\n            if (e.key === 'Enter') {\n              handleAddKeyword();\n            }\n          }}\n        />\n        <button onClick={handleAddKeyword} style={{\n          padding: '10px 15px',\n          fontSize: '16px',\n          cursor: 'pointer',\n          background: '#5cb85c',\n          color: 'white',\n          border: 'none',\n          borderRadius: '5px'\n        }}>\n          추가\n        </button>\n      </div>\n\n      <div style={{ \n        display: 'flex', \n        flexWrap: 'wrap', \n        gap: '8px', \n        justifyContent: 'center', \n        width: '100%', \n        padding: '10px 0', \n        minHeight: '50px' \n      }}>\n        {userKeywords.length > 0 ? userKeywords.map((keyword, index) => (\n          <span key={index} style={{\n            padding: '8px 15px',\n            background: '#ffc0cb',\n            borderRadius: '30px',\n            fontSize: '18px'\n          }}>\n            {keyword}\n          </span>\n        )) : (\n          <span style={{color: '#888', fontSize: '16px'}}>입력한 키워드가 여기에 표시됩니다.</span>\n        )}\n      </div>\n      <div style={{ display: 'flex', gap: '20px', marginTop: 'auto', justifyContent: 'center' }}>\n        {/* 긍정 버튼 - 동그라미, 노란색 */}\n        <button \n          onClick={() => userKeywords.length > 0 && onEmojiSelect && onEmojiSelect(emoji, userKeywords, 'positive')} \n          onMouseEnter={() => setHoveredButton('positive')}\n          onMouseLeave={() => setHoveredButton(null)}\n          disabled={userKeywords.length === 0}\n          style={{\n            width: '80px',\n            height: '80px',\n          fontSize: '16px',\n            fontWeight: 'bold',\n            cursor: userKeywords.length > 0 ? 'pointer' : 'not-allowed',\n            background: userKeywords.length > 0 ? '#FFD700' : '#cccccc',\n            color: userKeywords.length > 0 ? '#333' : '#666',\n          border: 'none',\n            borderRadius: '50%', // 동그라미\n            transition: 'all 0.3s ease',\n            boxShadow: hoveredButton === 'positive' && userKeywords.length > 0 \n              ? '0 0 20px #FFD700, 0 0 30px #FFD700, 0 0 40px #FFD700' \n              : '0 4px 8px rgba(0,0,0,0.2)',\n            transform: hoveredButton === 'positive' && userKeywords.length > 0 ? 'scale(1.05)' : 'scale(1)'\n          }}\n        >\n          긍정\n        </button>\n        \n        {/* 부정 버튼 - 네모, 빨간색 */}\n        <button \n          onClick={() => userKeywords.length > 0 && onEmojiSelect && onEmojiSelect(emoji, userKeywords, 'negative')} \n          onMouseEnter={() => setHoveredButton('negative')}\n          onMouseLeave={() => setHoveredButton(null)}\n          disabled={userKeywords.length === 0}\n          style={{\n            width: '80px',\n            height: '80px',\n          fontSize: '16px',\n            fontWeight: 'bold',\n            cursor: userKeywords.length > 0 ? 'pointer' : 'not-allowed',\n            background: userKeywords.length > 0 ? '#FF4444' : '#cccccc',\n            color: userKeywords.length > 0 ? 'white' : '#666',\n          border: 'none',\n            borderRadius: '8px', // 네모 (약간 둥글게)\n            transition: 'all 0.3s ease',\n            boxShadow: hoveredButton === 'negative' && userKeywords.length > 0 \n              ? '0 0 20px #FF4444, 0 0 30px #FF4444, 0 0 40px #FF4444' \n              : '0 4px 8px rgba(0,0,0,0.2)',\n            transform: hoveredButton === 'negative' && userKeywords.length > 0 ? 'scale(1.05)' : 'scale(1)'\n          }}\n        >\n          부정\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default GameModal; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/IconBarPlaceholder.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaleEmoji3D.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaleEmojis.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/ScaledScene.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/TextInputModal.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v4/constants.js",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker/v5/index.jsx",["376","377","378","379","380","381","382"],[],"import React, { useState, Suspense, useRef, useMemo, useEffect } from 'react';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { Environment, OrthographicCamera, useGLTF } from '@react-three/drei';\nimport { Physics, RigidBody } from '@react-three/rapier';\nimport { useControls } from 'leva';\nimport FullScreenContainer from '../../../components/mood-tracker/v4/FullScreenContainer';\nimport GameModal from '../../../components/mood-tracker/v4/GameModal';\nimport TextInputModal from '../../../components/mood-tracker/v4/TextInputModal';\nimport ScaledScene from '../../../components/mood-tracker/v4/ScaledScene';\nimport EmotionColumn from '../../../components/mood-tracker/v4/EmotionColumn';\nimport { FallingModelsScene } from '../../../components/mood-tracker/v4/FallingModels';\nimport EmojiSelector3D from '../../../components/mood-tracker/v4/EmojiSelector3D';\nimport Emoji3D from '../../../components/mood-tracker/v4/Emoji3D';\nimport BasketEmojiManager from '../../../components/mood-tracker/v5/BasketEmojiManager';\nimport PhysicsGround from '../../../components/mood-tracker/v5/PhysicsGround';\nimport { FallingSelectedEmojiScene } from '../../../components/mood-tracker/v4/FallingSelectedEmojiScene';\n\n// Emoji ID와 실제 Emoji 문자를 매핑합니다.\nconst emojiIdToChar = {\n  'joy': '😀',\n  'surprise': '😮',\n  'neutral': '😐',\n  'sadness': '😖',\n  'anger': '😠',\n};\n\n// --- 데이터 정의: 이모티콘별 키워드 ---\n// const emojiKeywords = { ... }; // Moved to components/mood-tracker/v4/constants.js\n\n// --- 스타일 컴포넌트: 전체 화면 컨테이너 ---\n// const FullScreenContainer = ({ children }) => ( ... ); // Moved\n\n// --- UI 컴포넌트: 하단 이모티콘 선택 바 ---\n// const IconBarPlaceholder = ({ onEmojiSelect }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 게임 모달 (이모티콘 클릭 시 표시) ---\n// const GameModal = ({ isOpen, emoji, onClose }) => { ... }; // Moved\n\n// --- UI 컴포넌트: 첫 화면 텍스트 입력 모달 ---\n// const TextInputModal = ({ isOpen, onClose, currentText, onTextChange, onSubmit }) => { ... }; // Moved\n\n// --- 3D 씬 컴포넌트: 저울 모델 및 크기 조정 로직 ---\n// function ScaledScene(props) { ... }; // Moved\n\n// --- 감정 컬럼(프레임) 컴포넌트 ---\n// function EmotionColumn({ emoji = '😀', keywords = [], sliderValue = 50, onSliderChange }) { ... }; // Moved\n\n// --- UI 컴포넌트: 게임 생성 모달 ---\nconst GameCreationModal = ({ isOpen, keyword, dominantEmojis = [], dominantKeywords, onClose, onStart }) => {\n  if (!isOpen) return null;\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      background: 'linear-gradient(135deg, #B02B3A 0%, #8B1E2B 100%)',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      zIndex: 2000,\n      animation: 'fadeIn 0.3s ease-in-out',\n      overflow: 'hidden'\n    }}>\n      {/* 3D 떨어지는 이모티콘 배경 */}\n      <div style={{\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        zIndex: 1\n      }}>\n        <Canvas camera={{ position: [0, 0, 5], fov: 50 }}>\n          <Suspense fallback={null}>\n            <ambientLight intensity={0.7} />\n            <directionalLight position={[0, 10, 10]} intensity={1} />\n            <directionalLight position={[0, -10, -5]} intensity={0.3} />\n            <FallingSelectedEmojiScene dominantEmojis={dominantEmojis} />\n          </Suspense>\n        </Canvas>\n      </div>\n\n      <div style={{\n        width: '80vw',\n        height: '70vh',\n        maxWidth: '800px',\n        maxHeight: '600px',\n        backgroundColor: 'rgba(255, 255, 255, 0.95)',\n        border: '3px solid #B02B3A',\n        borderRadius: '20px',\n        boxShadow: '0 15px 30px rgba(0, 0, 0, 0.3)',\n        padding: '40px',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'center',\n        gap: '30px',\n        position: 'relative',\n        backdropFilter: 'blur(10px)',\n        animation: 'slideIn 0.4s ease-out',\n        zIndex: 10\n      }}>\n        {/* 닫기 버튼 */}\n        <button\n          onClick={onClose}\n          style={{\n            position: 'absolute',\n            top: '15px',\n            right: '20px',\n            background: 'none',\n            border: 'none',\n            fontSize: '30px',\n            cursor: 'pointer',\n            color: '#B02B3A',\n            fontWeight: 'bold',\n            transition: 'transform 0.2s ease'\n          }}\n          onMouseOver={(e) => {\n            e.target.style.transform = 'scale(1.1)';\n          }}\n          onMouseOut={(e) => {\n            e.target.style.transform = 'scale(1)';\n          }}\n        >\n          ×\n        </button>\n\n        {/* 우세한 이모티콘들 표시 */}\n        <div style={{\n          fontSize: dominantEmojis.length > 1 ? '80px' : '120px',\n          marginBottom: '10px',\n          textShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'bounce 2s ease-in-out infinite',\n          display: 'flex',\n          flexWrap: 'wrap',\n          justifyContent: 'center',\n          alignItems: 'center',\n          gap: dominantEmojis.length > 1 ? '10px' : '0'\n        }}>\n          {dominantEmojis.length > 0 ? dominantEmojis.map((emoji, index) => (\n            <span key={index} style={{\n              fontSize: dominantEmojis.length > 3 ? '60px' : dominantEmojis.length > 1 ? '80px' : '120px'\n            }}>\n              {emoji}\n            </span>\n          )) : '😀'}\n        </div>\n\n        {/* 메인 문구 */}\n        <h1 style={{\n          textAlign: 'center',\n          fontSize: '28px',\n          fontWeight: 'bold',\n          color: '#B02B3A',\n          margin: '0',\n          lineHeight: '1.4',\n          animation: 'fadeInUp 0.6s ease-out'\n        }}>\n          오늘의 감정 생물을 만들어 보아요!\n        </h1>\n\n        {/* 키워드 표시 */}\n        <div style={{\n          padding: '15px 30px',\n          background: '#D2F2E9',\n          borderRadius: '25px',\n          fontSize: '18px',\n          fontWeight: '600',\n          color: '#333',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          animation: 'fadeInUp 0.8s ease-out',\n          textAlign: 'center',\n          minHeight: '50px',\n          display: 'flex',\n          flexWrap: 'wrap',\n          gap: '8px',\n          alignItems: 'center',\n          justifyContent: 'center'\n        }}>\n          {dominantKeywords && dominantKeywords.length > 0 ? (\n            dominantKeywords.map((keyword, index) => (\n              <span key={index} style={{\n                padding: '5px 12px',\n                borderRadius: '15px',\n                fontSize: '20px'\n              }}>\n                {keyword}\n              </span>\n            ))\n          ) : (\n            <span style={{ color: '#666', fontSize: '16px' }}>\n              감정 키워드가 없습니다\n            </span>\n          )}\n        </div>\n\n        {/* 게임 시작 버튼 */}\n        <button \n          style={{\n            padding: '15px 40px',\n            fontSize: '25px',\n            fontWeight: 'medium',\n            background: '#B02B3A',\n            color: 'white',\n            border: 'none',\n            borderRadius: '15px',\n            cursor: 'pointer',\n            boxShadow: '0 6px 12px rgba(176, 43, 58, 0.3)',\n            transition: 'all 0.3s ease',\n            marginTop: '20px',\n            animation: 'fadeInUp 1s ease-out'\n          }}\n          onMouseOver={(e) => {\n            e.target.style.transform = 'translateY(-2px)';\n            e.target.style.boxShadow = '0 8px 16px rgba(176, 43, 58, 0.4)';\n          }}\n          onMouseOut={(e) => {\n            e.target.style.transform = 'translateY(0)';\n            e.target.style.boxShadow = '0 6px 12px rgba(176, 43, 58, 0.3)';\n          }}\n          onClick={onStart}\n        >\n          Start\n        </button>\n      </div>\n\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes slideIn {\n          from { \n            opacity: 0;\n            transform: scale(0.8);\n          }\n          to { \n            opacity: 1;\n            transform: scale(1);\n          }\n        }\n        @keyframes fadeInUp {\n          from {\n            opacity: 0;\n            transform: translateY(20px);\n          }\n          to {\n            opacity: 1;\n            transform: translateY(0);\n          }\n        }\n        @keyframes bounce {\n          0%, 20%, 50%, 80%, 100% { transform: translateY(0); }\n          40% { transform: translateY(-10px); }\n          60% { transform: translateY(-5px); }\n        }\n        @keyframes fall {\n          0% {\n            transform: translateY(-50px) rotate(0deg);\n            opacity: 1;\n          }\n          100% {\n            transform: translateY(100vh) rotate(360deg);\n            opacity: 0;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\n// Float효과를 위한 3D 모델 컴포넌트\nconst FloatingModel = ({ url, position, rotationSpeed = 0.01, floatSpeed = 0.02, floatAmplitude = 0.5, scale = [0.8, 0.8, 0.8], onClick, shapeId }) => {\n  const groupRef = useRef();\n  const { scene } = useGLTF(url);\n  \n  useFrame((state) => {\n    if (groupRef.current) {\n      // 둥실거리는 효과\n      groupRef.current.position.y = position[1] + Math.sin(state.clock.elapsedTime * floatSpeed) * floatAmplitude;\n      // 회전 효과\n      groupRef.current.rotation.y += rotationSpeed;\n      groupRef.current.rotation.x += rotationSpeed * 0.5;\n    }\n  });\n\n  const handleClick = (event) => {\n    event.stopPropagation();\n    console.log(`Clicked on ${shapeId}`); // 디버깅용\n    if (onClick) {\n      onClick(shapeId);\n    }\n  };\n\n  const handlePointerOver = () => {\n    document.body.style.cursor = 'pointer';\n  };\n\n  const handlePointerOut = () => {\n    document.body.style.cursor = 'default';\n  };\n\n  return (\n    <group ref={groupRef} position={position}>\n      <primitive \n        object={scene.clone()} \n        scale={scale}\n      />\n      {/* 클릭 가능한 투명한 박스 */}\n      <mesh \n        onClick={handleClick}\n        onPointerOver={handlePointerOver}\n        onPointerOut={handlePointerOut}\n      >\n        <boxGeometry args={[2.5, 2.5, 2.5]} />\n        <meshBasicMaterial transparent opacity={0} />\n      </mesh>\n    </group>\n  );\n};\n\n// --- 떨어지는 도형 컴포넌트 ---\nconst FallingShape = ({ shapeInfo, position, scale = [0.8, 0.8, 0.8] }) => {\n  const { scene } = useGLTF(getShapeModelPath(shapeInfo));\n  const clonedScene = useMemo(() => scene.clone(true), [scene]);\n\n  return (\n    <RigidBody\n      type=\"dynamic\"\n      position={position}\ncolliders=\"cuboid\"\n      restitution={0.3}\n      friction={0.8}\n    >\n      <primitive \n        object={clonedScene} \n        scale={scale}\n      />\n    </RigidBody>\n  );\n};\n\n// 떨어지는 3D 이모티콘 컴포넌트\nconst FallingEmoji = ({ emojiId, position, scale = [0.8, 0.8, 0.8] }) => {\n  const modelPath = `/models/emotion${{'joy': 1, 'surprise': 2, 'neutral': 3, 'sadness': 4, 'anger': 5}[emojiId] || 1}.gltf`;\n  const { scene } = useGLTF(modelPath);\n  const clonedScene = useMemo(() => scene.clone(true), [scene]);\n\n  return (\n    <RigidBody \n      type=\"dynamic\" \n      position={position}\n      colliders=\"hull\"\n      restitution={0.4}\n      friction={0.6}\n    >\n      <primitive \n        object={clonedScene} \n        scale={scale}\n      />\n    </RigidBody>\n  );\n};\n\n// 도형별 모델 경로 반환 함수\nconst getShapeModelPath = (shapeInfo) => {\n  const pathMap = {\n    '파란 네모': '/box.gltf',\n    '빨간 길쭉이': '/clinder.gltf',\n    '분홍 둥글이': '/circle.gltf',\n    '노란 뾰족이': '/hexagon.gltf',\n    '초록 별': '/star.gltf'\n  };\n  return pathMap[shapeInfo.name] || '/box.gltf';\n};\n\n// --- 가상 바닥 컴포넌트 ---\nconst InvisibleGround = () => {\n  return (\n    <RigidBody type=\"fixed\" position={[0, -3, 0]}>\n      <mesh>\n        <boxGeometry args={[20, 0.1, 20]} />\n        <meshStandardMaterial \n          color=\"#F5E6A8\" \n          transparent \n          opacity={0} // 완전히 투명하게\n        />\n      </mesh>\n    </RigidBody>\n  );\n};\n\n// 도형 게임창 모달 컴포넌트\nconst ShapeGameModal = ({ isOpen, shapeInfo, onClose, onSelect }) => {\n  if (!isOpen || !shapeInfo) return null;\n\n  return (\n    <div style={{\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100vw',\n      height: '100vh',\n      background: 'rgba(0, 0, 0, 0.7)',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      zIndex: 3000,\n      animation: 'fadeIn 0.3s ease-in-out'\n    }}>\n      <div style={{\n        width: '500px',\n        height: '400px',\n        backgroundColor: 'white',\n        borderRadius: '20px',\n        boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)',\n        padding: '40px',\n        display: 'flex',\n        flexDirection: 'column',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        position: 'relative',\n        animation: 'slideIn 0.4s ease-out'\n      }}>\n        {/* 도형 이모티콘 */}\n        <div style={{\n          fontSize: '80px',\n          margin: '0',\n          textAlign: 'center'\n        }}>\n          {shapeInfo.emoji || shapeInfo.name}\n        </div>\n\n        {/* 도형 설명 */}\n        <p style={{\n          fontSize: '20px',\n          color: '#555',\n          textAlign: 'center',\n          lineHeight: '1.6',\n          margin: '20px 0',\n          flex: 1,\n          display: 'flex',\n          alignItems: 'center'\n        }}>\n          {shapeInfo.description}\n        </p>\n\n        {/* 버튼들 */}\n        <div style={{\n          display: 'flex',\n          gap: '20px',\n          alignItems: 'center'\n        }}>\n          {/* 선택 버튼 */}\n          <button\n            onClick={() => {\n              if (onSelect) onSelect(shapeInfo);\n              onClose();\n            }}\n            style={{\n              padding: '12px 40px',\n              backgroundColor: '#4CAF50',\n              color: 'white',\n              border: 'none',\n              borderRadius: '25px',\n              fontSize: '18px',\n              fontWeight: 'bold',\n              cursor: 'pointer',\n              transition: 'all 0.2s ease',\n              boxShadow: '0 4px 12px rgba(76, 175, 80, 0.3)'\n            }}\n            onMouseOver={(e) => {\n              e.target.style.backgroundColor = '#45a049';\n              e.target.style.transform = 'translateY(-2px)';\n            }}\n            onMouseOut={(e) => {\n              e.target.style.backgroundColor = '#4CAF50';\n              e.target.style.transform = 'translateY(0)';\n            }}\n          >\n            선택\n          </button>\n\n          {/* 닫기 버튼 */}\n          <button\n            onClick={onClose}\n            style={{\n              padding: '12px 40px',\n              backgroundColor: '#ff6b6b',\n              color: 'white',\n              border: 'none',\n              borderRadius: '25px',\n              fontSize: '18px',\n              fontWeight: 'bold',\n              cursor: 'pointer',\n              transition: 'all 0.2s ease',\n              boxShadow: '0 4px 12px rgba(255, 107, 107, 0.3)'\n            }}\n            onMouseOver={(e) => {\n              e.target.style.backgroundColor = '#ff5252';\n              e.target.style.transform = 'translateY(-2px)';\n            }}\n            onMouseOut={(e) => {\n              e.target.style.backgroundColor = '#ff6b6b';\n              e.target.style.transform = 'translateY(0)';\n            }}\n          >\n            닫기\n          </button>\n        </div>\n      </div>\n\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n        @keyframes slideIn {\n          from { \n            opacity: 0;\n            transform: translateY(-30px) scale(0.9);\n          }\n          to { \n            opacity: 1;\n            transform: translateY(0) scale(1);\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\n// --- 생물 만들기 페이지 컴포넌트 ---\nconst CreationPage = ({ onBack, keyword, dominantEmojis, dominantKeywords, positiveEmojis, negativeEmojis, leftSliderValue, rightSliderValue }) => {\n  const [isShapeGameModalOpen, setIsShapeGameModalOpen] = useState(false);\n  const [selectedShapeInfo, setSelectedShapeInfo] = useState(null);\n  const [selectedShapes, setSelectedShapes] = useState([]); // 선택된 도형들 저장\n  const [fallingEmojis, setFallingEmojis] = useState([]); // 떨어지는 이모티콘들\n\n  // 도형 ID에서 모델 경로 반환하는 함수\n  const getShapeModelPathById = (shapeId) => {\n    const shapeModels = {\n      'box': '/box.gltf',\n      'cylinder': '/clinder.gltf',\n      'circle': '/circle.gltf',\n      'hexagon': '/hexagon.gltf',\n      'star': '/star.gltf'\n    };\n    return shapeModels[shapeId] || '/box.gltf';\n  };\n\n  // 페이지 로드 시 떨어지는 이모티콘들 생성\n  useEffect(() => {\n    const emojis = [];\n    const emojiCharToId = {'😀': 'joy', '😮': 'surprise', '😐': 'neutral', '😖': 'sadness', '😠': 'anger'};\n    \n    // 긍정 이모티콘들 추가 (왼쪽에서 떨어짐)\n    positiveEmojis.forEach((emojiChar, index) => {\n      const emojiId = emojiCharToId[emojiChar];\n      if (emojiId) {\n        for (let i = 0; i < leftSliderValue; i++) {\n          emojis.push({\n            id: `positive-${index}-${i}-${Date.now()}`,\n            emojiId,\n            position: [\n              -8 + Math.random() * 6, // 왼쪽 영역을 훨씬 더 넓게 (-8에서 -2)\n              8 + Math.random() * 6, // 더 높은 위치에서 시작 (8에서 14)\n              -6 + Math.random() * 4 // 뒤쪽에서 떨어지게 (-6에서 -2)\n            ]\n          });\n        }\n      }\n    });\n\n    // 부정 이모티콘들 추가 (오른쪽에서 떨어짐)\n    negativeEmojis.forEach((emojiChar, index) => {\n      const emojiId = emojiCharToId[emojiChar];\n      if (emojiId) {\n        for (let i = 0; i < rightSliderValue; i++) {\n          emojis.push({\n            id: `negative-${index}-${i}-${Date.now()}`,\n            emojiId,\n            position: [\n              2 + Math.random() * 6, // 오른쪽 영역을 훨씬 더 넓게 (2에서 8)\n              8 + Math.random() * 6, // 더 높은 위치에서 시작 (8에서 14)\n              -6 + Math.random() * 4 // 뒤쪽에서 떨어지게 (-6에서 -2)\n            ]\n          });\n        }\n      }\n    });\n\n    setFallingEmojis(emojis);\n  }, [positiveEmojis, negativeEmojis, leftSliderValue, rightSliderValue]);\n\n  // 도형 정보 정의\n  const shapeInfoMap = {\n    'box': {\n      name: '파란 네모',\n      description: '나는 뾰족하지만 넓은 마음을 가지고 있어!',\n      emoji: '😀'\n    },\n    'cylinder': {\n      name: '빨간 길쭉이',\n      description: '나는 길쭉길쭉하고 동글동글하지만 강해!',\n      emoji: '😮'\n    },\n    'circle': {\n      name: '분홍 둥글이',\n      description: '나는 둥그렇게 돌아가지! 때에 따라 다양한 모습으로 변할 수 있어',\n      emoji: '😐'\n    },\n    'hexagon': {\n      name: '노란 뾰족이',\n      description: '나는 뾰족뾰족! 날카롭지만 다양한 모습을 가지고 있어',\n      emoji: '😖'\n    },\n    'star': {\n      name: '초록 별',\n      description: '나는 반짝반짝 빛나는 별이야!',\n      emoji: '😠'\n    }\n  };\n\n  // 이모티콘과 도형 연결 매핑 (기쁨-파란 네모 / 놀람-빨간 기둥 / 무표정-분홍 둥글이 / 슬픔-노란 뾰족이 / 화남-초록 별)\n  const emojiToShapeMap = {\n    'joy': 'box',        // 기쁨 -> 파란 네모\n    'surprise': 'cylinder', // 놀람 -> 빨간 기둥\n    'neutral': 'circle',    // 무표정 -> 분홍 둥글이\n    'sadness': 'hexagon',   // 슬픔 -> 노란 뾰족이\n    'anger': 'star'         // 화남 -> 초록 별\n  };\n\n  // 슬라이더 값에 따라 우세한 이모티콘 결정\n  const getDominantEmojis = () => {\n    if (leftSliderValue > rightSliderValue) {\n      return positiveEmojis;\n    } else if (rightSliderValue > leftSliderValue) {\n      return negativeEmojis;\n    } else {\n      // 같을 경우 모든 이모티콘 포함\n      return [...positiveEmojis, ...negativeEmojis];\n    }\n  };\n\n  // 우세한 이모티콘에서 첫 번째 이모티콘의 도형 ID 가져오기\n  const getDominantShapeId = () => {\n    const dominantEmojis = getDominantEmojis();\n    if (dominantEmojis.length > 0) {\n      // 첫 번째 이모티콘에서 이모티콘 ID 추출 (예: '😀' -> 'joy')\n      const emojiChar = dominantEmojis[0];\n      for (const [emojiId, emojiValue] of Object.entries({'joy': '😀', 'surprise': '😮', 'neutral': '😐', 'sadness': '😖', 'anger': '😠'})) {\n        if (emojiValue === emojiChar) {\n          return emojiToShapeMap[emojiId];\n        }\n      }\n    }\n    return 'box'; // 기본값\n  };\n\n  // 선택되지 않은 도형들 가져오기\n  const getUnselectedShapes = () => {\n    const dominantShapeId = getDominantShapeId();\n    return Object.keys(shapeInfoMap).filter(shapeId => shapeId !== dominantShapeId);\n  };\n\n  const handleShapeClick = (shapeId) => {\n    console.log(`handleShapeClick called with shapeId: ${shapeId}`); // 디버깅용\n    const shapeInfo = shapeInfoMap[shapeId];\n    console.log('Shape info:', shapeInfo); // 디버깅용\n    setSelectedShapeInfo(shapeInfo);\n    setIsShapeGameModalOpen(true);\n  };\n\n  // 이모티콘 클릭 핸들러 - 연결된 도형의 설명창을 엽니다\n  const handleEmojiClick = (emojiId) => {\n    console.log(`handleEmojiClick called with emojiId: ${emojiId}`); // 디버깅용\n    const shapeId = emojiToShapeMap[emojiId];\n    if (shapeId) {\n      const shapeInfo = shapeInfoMap[shapeId];\n      console.log('Shape info from emoji click:', shapeInfo); // 디버깅용\n      setSelectedShapeInfo(shapeInfo);\n      setIsShapeGameModalOpen(true);\n    }\n  };\n\n  const closeShapeGameModal = () => {\n    console.log('Closing shape game modal'); // 디버깅용\n    setIsShapeGameModalOpen(false);\n    // 약간의 지연을 두고 상태를 초기화\n    setTimeout(() => {\n      setSelectedShapeInfo(null);\n    }, 300);\n  };\n\n  const handleShapeSelect = (shapeInfo) => {\n    console.log('Shape selected:', shapeInfo);\n    // 선택된 도형을 배열에 추가\n    setSelectedShapes(prev => [...prev, {\n      ...shapeInfo,\n      id: Date.now(), // 고유 ID 생성\n      position: [\n        Math.random() * 4 - 2, // X: -2 ~ 2 범위\n        8, // Y: 높은 위치에서 시작\n        Math.random() * 4 - 2  // Z: -2 ~ 2 범위\n      ]\n    }]);\n  };\n\n  const dominantShapeId = getDominantShapeId();\n  const unselectedShapes = getUnselectedShapes();\n\n  return (\n    <div style={{\n      width: '100vw',\n      height: '100vh',\n      background: '#F5E6A8', // 베이지색으로 변경\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      fontFamily: 'Arial, sans-serif',\n      animation: 'fadeIn 0.5s ease-in-out',\n      position: 'relative'\n    }}>\n      <style jsx>{`\n        @keyframes fadeIn {\n          from { opacity: 0; }\n          to { opacity: 1; }\n        }\n      `}</style>\n\n      {/* 왼쪽 칼럼 */}\n      <div style={{\n        position: 'absolute',\n        left: '20px',\n        top: '50%',\n        transform: 'translateY(-50%)',\n        width: '250px',\n        height: '80%',\n        background: '#87CEEB', // 하늘색 배경으로 변경\n        borderRadius: '20px',\n        padding: '20px',\n        boxShadow: '0 8px 24px rgba(0,0,0,0.15)',\n        display: 'flex',\n        flexDirection: 'column',\n        zIndex: 10\n      }}>\n        {/* 상단: 감정 생물 만들기 */}\n        <div style={{\n          textAlign: 'center',\n          fontSize: '18px',\n          fontWeight: 'bold',\n          color: 'black', // 텍스트 색상을 검은색으로 변경\n          marginBottom: '20px',\n          padding: '10px',\n          background: 'white', // 완전 흰색 배경\n          borderRadius: '10px'\n        }}>\n          감정 생물 만들기\n        </div>\n\n        {/* 중간: 도형의 성격 */}\n        <div style={{\n          textAlign: 'center',\n          fontSize: '16px',\n          fontWeight: '600',\n          color: 'black', // 텍스트 색상을 검은색으로 변경\n          marginBottom: '15px',\n          padding: '8px',\n          background: 'white', // 완전 흰색 배경\n          borderRadius: '8px'\n        }}>\n          도형의 성격\n        </div>\n\n                {/* 선택되지 않은 도형들 세로 나열 */}\n        <div style={{\n          flex: 1,\n          display: 'flex',\n          flexDirection: 'column',\n          gap: '15px',\n          overflowY: 'auto'\n        }}>\n          {unselectedShapes.map((shapeId) => {\n            const shapeInfo = shapeInfoMap[shapeId];\n            return (\n              <div\n                key={shapeId}\n                onClick={() => handleShapeClick(shapeId)}\n                style={{\n                  height: '120px', // 높이를 100px에서 120px로 더 증가\n                  background: 'rgba(255, 255, 255, 0.9)',\n                  borderRadius: '10px',\n                  border: '2px solid rgba(255, 255, 255, 0.3)',\n                  cursor: 'pointer',\n                  textAlign: 'center',\n                  transition: 'all 0.2s ease',\n                  display: 'flex',\n                  alignItems: 'center',\n                  justifyContent: 'center',\n                  position: 'relative'\n                }}\n                onMouseEnter={(e) => {\n                  e.target.style.background = 'rgba(255, 255, 255, 1)';\n                  e.target.style.borderColor = 'rgba(255, 255, 255, 0.8)';\n                  e.target.style.transform = 'scale(1.05)';\n                }}\n                onMouseLeave={(e) => {\n                  e.target.style.background = 'rgba(255, 255, 255, 0.9)';\n                  e.target.style.borderColor = 'rgba(255, 255, 255, 0.3)';\n                  e.target.style.transform = 'scale(1)';\n                }}\n              >\n                <Canvas camera={{ position: [0, 0, 3], fov: 50 }} style={{ width: '100%', height: '100%' }}>\n                  <Suspense fallback={null}>\n                    <ambientLight intensity={0.7} />\n                    <directionalLight position={[2, 2, 2]} intensity={1} />\n                    <FloatingModel\n                       url={getShapeModelPathById(shapeId)}\n                       position={[0, 0, 0]}\n                       rotationSpeed={0.02}\n                       floatSpeed={0.05}\n                       floatAmplitude={0.1}\n                       scale={[1.2, 1.2, 1.2]} // 스케일을 0.8에서 1.2로 증가\n                       onClick={handleShapeClick}\n                       shapeId={shapeId}\n                     />\n                  </Suspense>\n                </Canvas>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n      \n      {/* 뒤로 가기 버튼 */}\n      <button\n        onClick={onBack}\n        style={{\n          position: 'absolute',\n          top: '30px',\n          left: '30px',\n          width: '50px',\n          height: '50px',\n          background: 'rgba(255, 255, 255, 0.9)',\n          border: '5px solid #B02B3A',\n          borderRadius: '50%',\n          cursor: 'pointer',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontSize: '24px',\n          color: '#B02B3A',\n          fontWeight: 'bold',\n          boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n          zIndex: 100,\n          transition: 'all 0.2s ease'\n        }}\n        onMouseOver={(e) => {\n          e.target.style.background = '#B02B3A';\n          e.target.style.color = 'white';\n          e.target.style.transform = 'scale(1.1)';\n        }}\n        onMouseOut={(e) => {\n          e.target.style.background = 'rgba(255, 255, 255, 0.9)';\n          e.target.style.color = '#B02B3A';\n          e.target.style.transform = 'scale(1)';\n        }}\n              >\n          ⬅\n        </button>\n      \n      {/* 상단에 우세한 이모티콘과 키워드 표시 */}\n      <div style={{\n        position: 'absolute',\n        top: '30px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        background: 'rgba(255, 255, 255, 0.9)',\n        borderRadius: '15px',\n        padding: '20px',\n        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n        zIndex: 100,\n        textAlign: 'center',\n        minWidth: '300px',\n        maxWidth: '80%'\n      }}>\n        {/* 우세한 이모티콘 표시 */}\n        <div style={{\n          fontSize: '60px',\n          marginBottom: '10px',\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          gap: '10px',\n          flexWrap: 'wrap'\n        }}>\n          {dominantEmojis && dominantEmojis.length > 0 ? dominantEmojis.map((emoji, index) => (\n            <span key={index}>{emoji}</span>\n          )) : '😀'}\n        </div>\n        \n        {/* 키워드 표시 */}\n        <div style={{\n          display: 'flex',\n          flexWrap: 'wrap',\n          gap: '8px',\n          justifyContent: 'center',\n          alignItems: 'center',\n          marginBottom: '15px'\n        }}>\n          {dominantKeywords && dominantKeywords.length > 0 ? (\n            dominantKeywords.map((keyword, index) => (\n              <span key={index} style={{\n                padding: '5px 12px',\n                background: '#D2F2E9',\n                borderRadius: '15px',\n                fontSize: '16px',\n                fontWeight: '500',\n                color: '#333'\n              }}>\n                {keyword}\n              </span>\n            ))\n          ) : (\n            <span style={{ color: '#666', fontSize: '14px' }}>\n              감정 키워드가 없습니다\n            </span>\n          )}\n        </div>\n        \n        {/* 추가 설명 문구 */}\n        <div style={{\n          fontSize: '18px',\n          color: '#555',\n          textAlign: 'center',\n          fontWeight: '500',\n          lineHeight: '1.4'\n        }}>\n          도형의 성격을 알아보고 감정 생물 만들기 시작\n        </div>\n      </div>\n      \n      {/* 3D 씬 */}\n      <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}>\n        <Suspense fallback={null}>\n          <ambientLight intensity={0.25} color=\"#FFFFFF\" />\n          <directionalLight \n            position={[8, 10, 5]} \n            intensity={0.2} \n            castShadow\n            shadow-mapSize-width={1024}\n            shadow-mapSize-height={1024}\n          />\n          <directionalLight \n            position={[-8, 5, -8]} \n            intensity={0.1}\n            color=\"#E3F2FD\"\n          />\n          <Environment preset=\"sunset\" intensity={0.8} blur={0.5} />\n          \n          <Physics>\n            {/* 가상 바닥 */}\n            <InvisibleGround />\n            \n            {/* 선택된 도형들 - 떨어지는 효과 */}\n            {selectedShapes.map((shape) => (\n              <FallingShape\n                key={shape.id}\n                shapeInfo={shape}\n                position={shape.position}\n                scale={[0.8, 0.8, 0.8]}\n              />\n            ))}\n            \n            {/* 떨어지는 3D 이모티콘들 */}\n            {fallingEmojis.map((emoji) => (\n              <FallingEmoji\n                key={emoji.id}\n                emojiId={emoji.emojiId}\n                position={emoji.position}\n                scale={[4, 4, 4]}\n              />\n            ))}\n            \n            {/* 하단의 우세한 이모티콘만 표시 */}\n            {(() => {\n              const dominantEmojis = getDominantEmojis();\n              const emojiIdToChar = {'joy': '😀', 'surprise': '😮', 'neutral': '😐', 'sadness': '😖', 'anger': '😠'};\n              \n              return dominantEmojis.map((emojiChar, index) => {\n                for (const [emojiId, emojiValue] of Object.entries(emojiIdToChar)) {\n                  if (emojiValue === emojiChar) {\n                    return (\n                      <group key={emojiId}>\n                        {/* 해당 이모티콘의 3D 모델 표시 */}\n                        <Emoji3D\n                          emojiId={emojiId}\n                          modelPath={`/models/emotion${Object.keys(emojiIdToChar).indexOf(emojiId) + 1}.gltf`}\n                          initialPosition={[index * 1.2 - (dominantEmojis.length - 1) * 0.6, 0.3, 4.7]}\n                          scale={0.93}\n                          onClick={handleEmojiClick}\n                        />\n                      </group>\n                    );\n                  }\n                }\n                return null;\n              });\n            })()}\n            \n            {/* 우세한 도형만 중앙에 표시 */}\n            {(() => {\n              const getShapeModelPath = (shapeId) => {\n                const shapeModels = {\n                  'box': '/box.gltf',\n                  'cylinder': '/clinder.gltf',\n                  'circle': '/circle.gltf',\n                  'hexagon': '/hexagon.gltf',\n                  'star': '/star.gltf'\n                };\n                return shapeModels[shapeId];\n              };\n\n              return (\n                <FloatingModel \n                  url={getShapeModelPath(dominantShapeId)} \n                  position={[0, 0, 0]} \n                  rotationSpeed={0.009}\n                  floatSpeed={0.016}\n                  floatAmplitude={0.38}\n                  scale={[1.2, 1.2, 1.2]}\n                  onClick={handleShapeClick}\n                  shapeId={dominantShapeId}\n                />\n              );\n            })()}\n          </Physics>\n        </Suspense>\n      </Canvas>\n\n      {/* 도형 게임창 모달 */}\n      <ShapeGameModal \n        isOpen={isShapeGameModalOpen}\n        shapeInfo={selectedShapeInfo}\n        onClose={closeShapeGameModal}\n        onSelect={handleShapeSelect}\n      />\n    </div>\n  );\n};\n\n// --- 메인 페이지 컴포넌트: MoodTrackerPage ---\nexport default function MoodTrackerPage() {\n  const [showLanding, setShowLanding] = useState(true);\n  const [isGameModalOpen, setIsGameModalOpen] = useState(false);\n  const [selectedEmojiForGameModal, setSelectedEmojiForGameModal] = useState(null);\n  const [isTextInputModalOpen, setIsTextInputModalOpen] = useState(false);\n  const [userInputText, setUserInputText] = useState('');\n  const [positiveEmojis, setPositiveEmojis] = useState([]); // 긍정 이모티콘들\n  const [negativeEmojis, setNegativeEmojis] = useState([]); // 부정 이모티콘들\n  const [positiveKeywords, setPositiveKeywords] = useState([]); // 긍정 키워드들\n  const [negativeKeywords, setNegativeKeywords] = useState([]); // 부정 키워드들\n  const [leftSliderValue, setLeftSliderValue] = useState(0);\n  const [rightSliderValue, setRightSliderValue] = useState(0);\n  const [showInstructions, setShowInstructions] = useState(true);\n  const [isGameCreationModalOpen, setIsGameCreationModalOpen] = useState(false); // 게임 생성 모달 상태\n  const [showCreationPage, setShowCreationPage] = useState(false); // 생물 만들기 페이지 상태\n  const [showColumns, setShowColumns] = useState(false); // 양쪽 칼럼 표시 상태\n  const audioRef = useRef(null); // 배경음악을 위한 ref\n  \n  // Leva를 사용한 바구니 이모티콘 조정 컨트롤\n  const { \n    emojiScale, \n    emojiSpacing, \n    basketHeight, \n    basketCapacity,\n    leftBasketX,\n    rightBasketX,\n    randomnessRange,\n    animationSpeed,\n    bobAmplitude,\n    zPositionRange,\n    zPositionOffset\n  } = useControls('바구니 이모티콘 설정', {\n    emojiScale: { \n      value: 1.33, \n      min: 0.1, \n      max: 1.5, \n      step: 0.05,\n      label: '이모티콘 크기'\n    },\n    emojiSpacing: { \n      value: 0.25, \n      min: 0.2, \n      max: 0.6, \n      step: 0.05,\n      label: '이모티콘 간격'\n    },\n    basketHeight: { \n      value: 2.1, \n      min: 1.0, \n      max: 5.0, \n      step: 0.1,\n      label: '바구니 높이'\n    },\n    basketCapacity: { \n      value: 20, \n      min: 5, \n      max: 30, \n      step: 1,\n      label: '바구니 용량'\n    },\n    leftBasketX: { \n      value: -1.3, \n      min: -3, \n      max: -1, \n      step: 0.1,\n      label: '왼쪽 바구니 X 위치'\n    },\n    rightBasketX: { \n      value: 1.6, \n      min: 0.5, \n      max: 2.5, \n      step: 0.1,\n      label: '오른쪽 바구니 X 위치'\n    },\n    randomnessRange: { \n      value: 0.11, \n      min: 0, \n      max: 0.3, \n      step: 0.01,\n      label: '랜덤 위치 범위'\n    },\n    animationSpeed: { \n      value: 1.4, \n      min: 0.1, \n      max: 2.0, \n      step: 0.1,\n      label: '애니메이션 속도'\n    },\n    bobAmplitude: { \n      value: 0.07, \n      min: 0, \n      max: 0.1, \n      step: 0.01,\n      label: '위아래 움직임 크기'\n    },\n    zPositionRange: { \n      value: 0.45, \n      min: 0.05, \n      max: 0.5, \n      step: 0.05,\n      label: 'Z축 위치 범위 (바구니 깊이)'\n    },\n    zPositionOffset: { \n      value: -0.2, \n      min: -0.3, \n      max: 0.3, \n      step: 0.05,\n      label: 'Z축 위치 오프셋 (앞뒤 조절)'\n    }\n  });\n\n  // 슬라이더 값에 따른 저울 기울기 계산\n  const calculateTiltAngle = () => {\n    const difference = rightSliderValue - leftSliderValue;\n    const maxTilt = Math.PI / 8; // 최대 기울기 각도를 좀 더 크게 (22.5도)\n    const normalizedDifference = difference / 10; // 슬라이더는 0-10 범위이므로\n    const tiltAngle = normalizedDifference * maxTilt;\n    \n    return tiltAngle; // 양수면 오른쪽으로 기울어짐, 음수면 왼쪽으로 기울어짐\n  };\n\n  const bodyProps = { position: [0, 0.5, 0], scale: 1.9, rotation: [0, 0, 0] };\n  const wingsProps = { position: [0, -0.02, 0], scale: 1.1, rotation: [0, 0, 0] };\n  const wingsPrimitiveOffset = [0, 0, 0];\n\n  const handleEmoji3DClick = (emojiId) => {\n    // 처음 이모티콘 클릭시 안내 문구 숨기기\n    if (showInstructions) {\n      setShowInstructions(false);\n    }\n    \n    const emojiChar = emojiIdToChar[emojiId];\n    if (emojiChar) {\n      setSelectedEmojiForGameModal(emojiChar);\n      setIsGameModalOpen(true);\n    }\n  };\n\n  const closeGameModal = () => {\n    setIsGameModalOpen(false);\n    setSelectedEmojiForGameModal(null);\n  };\n\n  const handleEmojiSelection = (emoji, keywords, type) => {\n    if (type === 'positive') {\n      setPositiveEmojis(prev => [...prev, emoji]);\n      setPositiveKeywords(prev => [...prev, ...keywords]);\n    } else if (type === 'negative') {\n      setNegativeEmojis(prev => [...prev, emoji]);\n      setNegativeKeywords(prev => [...prev, ...keywords]);\n    }\n    // 긍정/부정 버튼 클릭 시 양쪽 칼럼 표시\n    setShowColumns(true);\n    closeGameModal();\n  };\n\n  const handleKeywordUpdate = (emoji, keywords) => {\n    // 키워드 업데이트 기능 (필요시 구현)\n  };\n\n  const handlePlayClick = () => {\n    setIsTextInputModalOpen(true);\n  };\n\n  const handleTextInputSubmit = (text) => {\n    setUserInputText(text);\n    setShowLanding(false);\n  };\n\n  const handleStartGame = () => {\n    setIsGameCreationModalOpen(true);\n  };\n\n  const closeGameCreationModal = () => {\n    setIsGameCreationModalOpen(false);\n  };\n\n  const handleStartCreation = () => {\n    setIsGameCreationModalOpen(false);\n    setShowCreationPage(true);\n  };\n\n  const handleBackToMain = () => {\n    setShowCreationPage(false);\n    setShowLanding(true);\n    // 관련 상태들도 초기화\n    setShowColumns(false);\n    setPositiveEmojis([]);\n    setNegativeEmojis([]);\n    setPositiveKeywords([]);\n    setNegativeKeywords([]);\n    setLeftSliderValue(0);\n    setRightSliderValue(0);\n    \n    // 배경음악이 계속 재생되도록 보장\n    setTimeout(() => {\n      if (audioRef.current && audioRef.current.paused) {\n        audioRef.current.play().catch(error => {\n          console.log('뒤로가기 시 오디오 재생 실패:', error);\n        });\n      }\n    }, 100);\n  };\n\n  // 배경음악 초기화 및 재생\n  useEffect(() => {\n    const initializeAudio = () => {\n      if (audioRef.current) {\n        audioRef.current.volume = 0.3; // 볼륨 설정 (0.0 ~ 1.0)\n        audioRef.current.loop = true; // 반복 재생\n      audioRef.current.preload = 'auto'; // 자동 미리 로드\n        \n        // 사용자 상호작용 후 재생하기 위한 함수\n        const playAudio = () => {\n          if (audioRef.current && audioRef.current.paused) {\n            audioRef.current.play().catch(error => {\n              console.log('오디오 재생 실패:', error);\n            });\n          }\n        };\n\n        // 클릭 이벤트 리스너 등록 (한 번만)\n        document.addEventListener('click', playAudio, { once: true });\n        \n        return () => {\n          document.removeEventListener('click', playAudio);\n        };\n      }\n    };\n\n    initializeAudio();\n  }, []);\n\n  // 페이지 전환 시에도 음악이 계속 재생되도록 보장\n  useEffect(() => {\n    const ensureAudioPlaying = () => {\n      if (audioRef.current) {\n        // 음악이 일시정지되어 있으면 다시 재생\n        if (audioRef.current.paused && audioRef.current.readyState >= 2) {\n          audioRef.current.play().catch(error => {\n            console.log('페이지 전환 시 오디오 재생 실패:', error);\n          });\n        }\n      }\n    };\n\n    // 약간의 지연을 두고 음악 재생 확인\n    const timer = setTimeout(ensureAudioPlaying, 100);\n    \n    return () => clearTimeout(timer);\n  }, [showLanding, showCreationPage]);\n\n  // 우세한 이모티콘들 결정 (슬라이더 값 기반으로 변경)\n  const dominantEmojis = leftSliderValue > rightSliderValue ? positiveEmojis : negativeEmojis;\n  \n  // 우세한 키워드 가져오기 (슬라이더 값 기반으로 변경)\n  const dominantKeywords = leftSliderValue > rightSliderValue ? positiveKeywords : negativeKeywords;\n\n  const keywords = ['기쁨', '즐거움', '행복함', '밝음', '신남', '부드러움', '통통튀는', '화창한'];\n\n  // Implementation of showCreationPage\n  if (showCreationPage) {\n    return (\n      <>\n      <CreationPage\n        onBack={handleBackToMain}\n        keyword={userInputText || '감정'}\n        dominantEmojis={dominantEmojis}\n        dominantKeywords={dominantKeywords}\n        positiveEmojis={positiveEmojis}\n        negativeEmojis={negativeEmojis}\n        leftSliderValue={leftSliderValue}\n        rightSliderValue={rightSliderValue}\n      />\n        \n        {/* 배경음악 - 세번째 화면에서도 계속 재생 */}\n        <audio \n          ref={audioRef} \n          preload=\"auto\"\n          src=\"/bgm.mp3\"\n          style={{ display: 'none' }}\n          loop\n        />\n      </>\n    );\n  }\n\n  if (showLanding) {\n    return (\n      <>\n      <div style={{\n        width: '100vw',\n        height: '100vh',\n        display: 'flex',\n        alignItems: 'center',\n        background: 'url(/first.png) center/cover no-repeat',\n        flexDirection: 'column',\n        position: 'relative',\n        overflow: 'hidden'\n      }}>\n        <div style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', zIndex: 2 }}>\n          <Canvas>\n            <OrthographicCamera\n              makeDefault\n              position={[0, 0, 100]} \n              zoom={25}\n            />\n            <Suspense fallback={null}>\n              <FallingModelsScene />\n            </Suspense>\n          </Canvas>\n        </div>\n        <button\n          onClick={handlePlayClick}\n          style={{\n            padding: '30px 60px',\n            fontSize: '36px',\n            cursor: 'pointer',\n            background: 'white',\n            color: '#B02B3A',\n            border: '5px solid white',\n            borderRadius: '25px',\n            fontWeight: 'bold',\n            boxShadow: '0 12px 24px rgba(0,0,0,0.4)',\n            zIndex: 3,\n            position: 'absolute',\n            bottom: '100px',\n            left: '50%',\n            transform: 'translateX(-50%)'\n          }}\n        >\n          Play\n        </button>\n        <TextInputModal\n          isOpen={isTextInputModalOpen}\n          onClose={() => setIsTextInputModalOpen(false)}\n          currentText={userInputText}\n          onTextChange={setUserInputText}\n          onSubmit={handleTextInputSubmit}\n        />\n      </div>\n        \n        {/* 배경음악 - 모든 페이지에서 공통으로 사용 */}\n        <audio \n          ref={audioRef} \n          preload=\"auto\"\n          src=\"/bgm.mp3\"\n          style={{ display: 'none' }}\n          loop\n        />\n      </>\n    );\n  }\n\n  // 현재 날짜와 시간 가져오기\n  const getCurrentDateTime = () => {\n    const now = new Date();\n    const year = now.getFullYear();\n    const month = now.getMonth() + 1;\n    const day = now.getDate();\n    const dayNames = ['일', '월', '화', '수', '목', '금', '토'];\n    const dayName = dayNames[now.getDay()];\n    const hour = now.getHours();\n    const minute = now.getMinutes().toString().padStart(2, '0');\n    \n    return `${year}년 ${month}월 ${day}일 (${dayName}) 오후 ${hour}:${minute}`;\n  };\n\n  return (\n    <>\n    <FullScreenContainer>\n      \n      {/* 만들기 시작 버튼 - 이모티콘이 있고 슬라이더가 조작되었을 때만 표시 */}\n      {showColumns && (positiveEmojis.length > 0 || negativeEmojis.length > 0) && (\n        <button\n          onClick={handleStartGame}\n          style={{\n            position: 'absolute',\n            bottom: '260px', // 하단 이모티콘 위쪽으로 이동\n            left: '50%',\n            transform: 'translateX(-50%)',\n            padding: '15px 30px',\n            fontSize: '22px',\n            fontWeight: 'bold',\n            background: 'white',\n            color: 'black',\n            border: 'none',\n            borderRadius: '18px',\n            boxShadow: '0 4px 12px rgba(176, 43, 58, 0.3)',\n            cursor: 'pointer',\n            zIndex: 100,\n            transition: 'all 0.3s ease',\n          }}\n          onMouseEnter={(e) => {\n            e.target.style.transform = 'translateX(-50%) scale(1.05)';\n            e.target.style.boxShadow = '0 6px 16px rgba(176, 43, 58, 0.4)';\n          }}\n          onMouseLeave={(e) => {\n            e.target.style.transform = 'translateX(-50%) scale(1)';\n            e.target.style.boxShadow = '0 4px 12px rgba(176, 43, 58, 0.3)';\n          }}\n        >\n          만들기 시작\n        </button>\n      )}\n      {showColumns && (\n        <div style={{ display: 'flex', width: '100%', height: '100%', justifyContent: 'space-between', alignItems: 'center', position: 'absolute', top: 0, left: 0, zIndex: 1 }}>\n          <EmotionColumn \n            emojis={positiveEmojis} \n            keywords={positiveKeywords} \n            sliderValue={leftSliderValue}\n            onSliderChange={setLeftSliderValue}\n          />\n          <EmotionColumn \n            emojis={negativeEmojis} \n            keywords={negativeKeywords} \n            sliderValue={rightSliderValue}\n            onSliderChange={setRightSliderValue}\n          />\n        </div>\n      )}\n      <div style={{ width: '90%', height: '90%', maxWidth: '1200px', maxHeight: '900px', position: 'relative', zIndex: 2 }}>\n        <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}> \n          <Suspense fallback={null}>\n            <ambientLight intensity={0.25} color=\"#FFFFFF\" />\n            <directionalLight \n              position={[8, 10, 5]} \n              intensity={0.2} \n              castShadow\n              shadow-mapSize-width={1024}\n              shadow-mapSize-height={1024}\n            />\n            <directionalLight \n              position={[-8, 5, -8]} \n              intensity={0.1}\n              color=\"#E3F2FD\"\n            />\n            <Environment preset=\"sunset\" intensity={0.8} blur={0.5} />\n                        <Physics>\n            <PhysicsGround />\n            <ScaledScene\n              bodyProps={bodyProps}\n              wingsProps={wingsProps}\n              wingsPrimitiveOffset={wingsPrimitiveOffset}\n              tiltAngle={calculateTiltAngle()}\n              verticalMovementFactor={0.03}\n            />\n              <EmojiSelector3D \n                onEmojiClick={handleEmoji3DClick} \n                />\n              <BasketEmojiManager\n                leftCount={positiveEmojis.length > 0 ? leftSliderValue : 0}\n                rightCount={negativeEmojis.length > 0 ? rightSliderValue : 0}\n                leftEmojiTypes={positiveEmojis}\n                rightEmojiTypes={negativeEmojis}\n                emojiScale={emojiScale}\n                emojiSpacing={emojiSpacing}\n                basketHeight={basketHeight}\n                basketCapacity={basketCapacity}\n                leftBasketX={leftBasketX}\n                rightBasketX={rightBasketX}\n                randomnessRange={randomnessRange}\n                animationSpeed={animationSpeed}\n                bobAmplitude={bobAmplitude}\n                zPositionRange={zPositionRange}\n                zPositionOffset={zPositionOffset}\n              />\n            </Physics>\n          </Suspense>\n        </Canvas>\n      </div>\n      {showInstructions && (\n        <div style={{\n          position: 'absolute',\n          bottom: '230px',\n          left: '50%',\n          transform: 'translateX(-50%)',\n          padding: '15px 30px',\n          background: 'rgba(135, 206, 235, 0.6)',\n          color: 'white',\n          borderRadius: '25px',\n          fontSize: '18px',\n          fontWeight: '500',\n          zIndex: 100,\n          textAlign: 'center',\n          whiteSpace: 'nowrap',\n          boxShadow: '0 4px 12px rgba(0,0,0,0.3)',\n          fontFamily: 'Arial, sans-serif',\n        }}>\n          이모티콘을 클릭하고 오늘의 감정을 입력하세요\n        </div>\n      )}\n      <GameModal \n        isOpen={isGameModalOpen} \n        emoji={selectedEmojiForGameModal} \n        onClose={closeGameModal} \n        onEmojiSelect={handleEmojiSelection}\n        onKeywordUpdate={handleKeywordUpdate}\n        existingKeywords={[]}\n      />\n      <GameCreationModal\n        isOpen={isGameCreationModalOpen}\n        keyword={userInputText || '감정'}\n        dominantEmojis={dominantEmojis}\n        dominantKeywords={dominantKeywords}\n        onClose={closeGameCreationModal}\n        onStart={handleStartCreation}\n      />\n    </FullScreenContainer>\n      \n      {/* 배경음악 - 모든 페이지에서 공통으로 사용 */}\n      <audio \n        ref={audioRef} \n        preload=\"auto\"\n        src=\"/bgm.mp3\"\n        style={{ display: 'none' }}\n        loop\n      />\n    </>\n  );\n}","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/BasketEmoji3D.jsx",["383"],[],"import React, { useRef, useMemo } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\n\nconst BasketEmoji3D = ({ \n  emoji, \n  position, \n  basketSide, \n  scale = 0.2, \n  animationSpeed = 0.5, \n  bobAmplitude = 0.03 \n}) => {\n  const meshRef = useRef();\n  \n  // 이모티콘에 따른 3D 모델 매핑\n  const emojiToModel = useMemo(() => {\n    const mapping = {\n      '😀': '/models/emotion1.gltf',\n      '😮': '/models/emotion2.gltf', \n      '😐': '/models/emotion3.gltf',\n      '😖': '/models/emotion4.gltf',\n      '😠': '/models/emotion5.gltf'\n    };\n    return mapping[emoji] || '/models/emotion1.gltf';\n  }, [emoji]);\n  \n  const { scene } = useGLTF(emojiToModel);\n  \n  // 각 이모티콘별로 고유한 애니메이션 오프셋 생성\n  const animationOffset = useMemo(() => Math.random() * Math.PI * 2, []);\n  const bobSpeed = useMemo(() => animationSpeed + Math.random() * animationSpeed, [animationSpeed]);\n  const actualBobAmplitude = useMemo(() => bobAmplitude + Math.random() * bobAmplitude, [bobAmplitude]);\n  \n  useFrame((state) => {\n    if (meshRef.current) {\n      // 부드러운 위아래 움직임 (숨쉬는 듯한 효과)\n      const bobOffset = Math.sin(state.clock.elapsedTime * bobSpeed + animationOffset) * actualBobAmplitude;\n      meshRef.current.position.y = position[1] + bobOffset;\n      \n      // 미세한 회전 효과\n      const rotationOffset = Math.sin(state.clock.elapsedTime * 0.3 + animationOffset) * 0.1;\n      meshRef.current.rotation.z = rotationOffset;\n    }\n  });\n\n  return (\n    <primitive \n      ref={meshRef} \n      object={scene.clone()} \n      position={[position[0], position[1], position[2]]}\n      scale={[scale, scale, scale]}\n    />\n  );\n};\n\nexport default BasketEmoji3D; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/BasketEmojiManager.jsx",["384","385","386","387"],[],"import React, { useMemo } from 'react';\nimport BasketEmoji3D from './BasketEmoji3D';\nimport OverflowEmojiManager from './OverflowEmojiManager';\n\nconst BasketEmojiManager = ({ \n  leftCount = 0, \n  rightCount = 0, \n  leftEmojiTypes = [], \n  rightEmojiTypes = [],\n  emojiScale = 0.2,\n  emojiSpacing = 0.3,\n  basketHeight = 1.2,\n  basketCapacity = 10,\n  leftBasketX = -2,\n  rightBasketX = 1,\n  randomnessRange = 0.1,\n  animationSpeed = 0.5,\n  bobAmplitude = 0.03,\n  zPositionRange = 0.2,\n  zPositionOffset = 0.0\n}) => {\n  \n  // 실제 바구니 내부 이모티콘과 넘치는 이모티콘 계산\n  const leftBasketCount = Math.min(leftCount, basketCapacity);\n  const leftOverflowCount = Math.max(0, leftCount - basketCapacity);\n  const rightBasketCount = Math.min(rightCount, basketCapacity);\n  const rightOverflowCount = Math.max(0, rightCount - basketCapacity);\n  \n  // 바구니의 실제 크기 (ScaledScene의 스케일링 고려) - 컴포넌트 외부로 이동\n  const ACTUAL_BASKET_RADIUS = 0.25; // 실제 바구니 반지름 (조정됨)\n  const SAFE_MARGIN = 0.03; // 여유 공간 (줄임)\n  const USABLE_RADIUS = ACTUAL_BASKET_RADIUS - SAFE_MARGIN;\n  \n  // 왼쪽 바구니 이모티콘들 생성\n  const leftEmojis = useMemo(() => {\n    const emojis = [];\n    \n    for (let i = 0; i < leftBasketCount; i++) {\n      const emojiType = leftEmojiTypes[i % leftEmojiTypes.length] || '😀';\n      \n      // 원형 배치로 변경 - 바구니는 원형이므로\n      const layer = Math.floor(i / 6); // 한 층에 최대 6개\n      const indexInLayer = i % 6;\n      const anglePerItem = (Math.PI * 2) / Math.max(1, Math.min(6, leftBasketCount - layer * 6));\n      const angle = indexInLayer * anglePerItem;\n      \n      // 층별로 반지름 줄이기\n      const layerRadius = USABLE_RADIUS * (1 - layer * 0.3);\n      const actualRadius = Math.max(0.05, layerRadius); // 최소 반지름 보장\n      \n      // 원형 배치 좌표 계산\n      const localX = Math.cos(angle) * actualRadius;\n      const localZ = Math.sin(angle) * actualRadius;\n      \n      // 일관된 시드 기반 랜덤 요소 - 인덱스를 시드로 사용하여 일관성 보장\n      const seedBasedRandomX = (Math.sin(i * 12.9898) * 43758.5453123) % 1;\n      const seedBasedRandomZ = (Math.sin(i * 78.233) * 43758.5453123) % 1;\n      const smallRandomness = Math.min(randomnessRange * 0.2, 0.03);\n      const randomX = (seedBasedRandomX - 0.5) * smallRandomness;\n      const randomZ = (seedBasedRandomZ - 0.5) * smallRandomness;\n      \n      // 최종 위치 계산 (바구니 중심 기준)\n      const x = leftBasketX + localX + randomX;\n      const z = zPositionOffset + localZ + randomZ;\n      const y = basketHeight + (layer * 0.15); // 층간 높이 차이\n      \n      // 바구니 경계 체크 - 반지름을 벗어나면 중심으로 끌어당김\n      const distanceFromCenter = Math.sqrt(\n        Math.pow(localX + randomX, 2) + Math.pow(localZ + randomZ, 2)\n      );\n      \n      let finalX = x;\n      let finalZ = z;\n      \n      if (distanceFromCenter > USABLE_RADIUS) {\n        const ratio = USABLE_RADIUS / distanceFromCenter;\n        finalX = leftBasketX + (localX + randomX) * ratio;\n        finalZ = zPositionOffset + (localZ + randomZ) * ratio;\n      }\n      \n      emojis.push({\n        id: `left-${i}`,\n        emoji: emojiType,\n        position: [finalX, y, finalZ]\n      });\n    }\n    return emojis;\n  }, [leftBasketCount, leftEmojiTypes, basketHeight, leftBasketX, randomnessRange, zPositionOffset]);\n\n  // 오른쪽 바구니 이모티콘들 생성\n  const rightEmojis = useMemo(() => {\n    const emojis = [];\n    \n    for (let i = 0; i < rightBasketCount; i++) {\n      const emojiType = rightEmojiTypes[i % rightEmojiTypes.length] || '😀';\n      \n      // 원형 배치로 변경 - 바구니는 원형이므로\n      const layer = Math.floor(i / 6); // 한 층에 최대 6개\n      const indexInLayer = i % 6;\n      const anglePerItem = (Math.PI * 2) / Math.max(1, Math.min(6, rightBasketCount - layer * 6));\n      const angle = indexInLayer * anglePerItem;\n      \n      // 층별로 반지름 줄이기\n      const layerRadius = USABLE_RADIUS * (1 - layer * 0.3);\n      const actualRadius = Math.max(0.05, layerRadius); // 최소 반지름 보장\n      \n      // 원형 배치 좌표 계산\n      const localX = Math.cos(angle) * actualRadius;\n      const localZ = Math.sin(angle) * actualRadius;\n      \n      // 일관된 시드 기반 랜덤 요소 - 오른쪽 바구니 전용 시드 (1000을 더해서 차별화)\n      const seedBasedRandomX = (Math.sin((i + 1000) * 12.9898) * 43758.5453123) % 1;\n      const seedBasedRandomZ = (Math.sin((i + 1000) * 78.233) * 43758.5453123) % 1;\n      const smallRandomness = Math.min(randomnessRange * 0.2, 0.03);\n      const randomX = (seedBasedRandomX - 0.5) * smallRandomness;\n      const randomZ = (seedBasedRandomZ - 0.5) * smallRandomness;\n      \n      // 최종 위치 계산 (바구니 중심 기준)\n      const x = rightBasketX + localX + randomX;\n      const z = zPositionOffset + localZ + randomZ;\n      const y = basketHeight + (layer * 0.15); // 층간 높이 차이\n      \n      // 바구니 경계 체크 - 반지름을 벗어나면 중심으로 끌어당김\n      const distanceFromCenter = Math.sqrt(\n        Math.pow(localX + randomX, 2) + Math.pow(localZ + randomZ, 2)\n      );\n      \n      let finalX = x;\n      let finalZ = z;\n      \n      if (distanceFromCenter > USABLE_RADIUS) {\n        const ratio = USABLE_RADIUS / distanceFromCenter;\n        finalX = rightBasketX + (localX + randomX) * ratio;\n        finalZ = zPositionOffset + (localZ + randomZ) * ratio;\n      }\n      \n      emojis.push({\n        id: `right-${i}`,\n        emoji: emojiType,\n        position: [finalX, y, finalZ]\n      });\n    }\n    return emojis;\n  }, [rightBasketCount, rightEmojiTypes, basketHeight, rightBasketX, randomnessRange, zPositionOffset]);\n\n  return (\n    <>\n      {/* 왼쪽 바구니 이모티콘들 */}\n      {leftEmojis.map((emojiData) => (\n        <BasketEmoji3D\n          key={emojiData.id}\n          emoji={emojiData.emoji}\n          position={emojiData.position}\n          basketSide=\"left\"\n          scale={emojiScale}\n          animationSpeed={animationSpeed}\n          bobAmplitude={bobAmplitude}\n        />\n      ))}\n      \n      {/* 오른쪽 바구니 이모티콘들 */}\n      {rightEmojis.map((emojiData) => (\n        <BasketEmoji3D\n          key={emojiData.id}\n          emoji={emojiData.emoji}\n          position={emojiData.position}\n          basketSide=\"right\"\n          scale={emojiScale}\n          animationSpeed={animationSpeed}\n          bobAmplitude={bobAmplitude}\n        />\n      ))}\n      \n      {/* 넘침 효과 */}\n      <OverflowEmojiManager\n        leftOverflowCount={leftOverflowCount}\n        rightOverflowCount={rightOverflowCount}\n        leftEmojiTypes={leftEmojiTypes}\n        rightEmojiTypes={rightEmojiTypes}\n        emojiScale={emojiScale}\n        leftBasketX={leftBasketX}\n        rightBasketX={rightBasketX}\n      />\n    </>\n  );\n};\n\nexport default BasketEmojiManager; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/OverflowEmoji3D.jsx",["388","389"],[],"import React, { useRef, useMemo } from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { useGLTF } from '@react-three/drei';\nimport { RigidBody } from '@react-three/rapier';\n\nconst OverflowEmoji3D = ({ emoji, position, initialVelocity, basketSide, scale = 0.15 }) => {\n  const rigidBodyRef = useRef();\n  \n  // 이모티콘에 따른 3D 모델 매핑\n  const emojiToModel = useMemo(() => {\n    const mapping = {\n      '😀': '/models/emotion1.gltf',\n      '😮': '/models/emotion2.gltf', \n      '😐': '/models/emotion3.gltf',\n      '😖': '/models/emotion4.gltf',\n      '😠': '/models/emotion5.gltf'\n    };\n    return mapping[emoji] || '/models/emotion1.gltf';\n  }, [emoji]);\n  \n  const { scene } = useGLTF(emojiToModel);\n  \n  // 생성 후 초기 속도 적용\n  React.useEffect(() => {\n    if (rigidBodyRef.current) {\n      // 약간의 지연 후 초기 속도 적용 (물리 객체가 준비된 후)\n      setTimeout(() => {\n        if (rigidBodyRef.current) {\n          rigidBodyRef.current.setLinvel({\n            x: initialVelocity.x,\n            y: initialVelocity.y,\n            z: initialVelocity.z\n          }, true);\n          \n          // 회전 속도도 추가\n          rigidBodyRef.current.setAngvel({\n            x: (Math.random() - 0.5) * 5,\n            y: (Math.random() - 0.5) * 5,\n            z: (Math.random() - 0.5) * 5\n          }, true);\n        }\n      }, 50);\n    }\n  }, [initialVelocity]);\n\n  return (\n    <RigidBody\n      ref={rigidBodyRef}\n      position={position}\n      mass={0.1}\n      restitution={0.6} // 탄성력\n      friction={0.7}\n      colliders=\"ball\"\n    >\n      <primitive \n        object={scene.clone()} \n        scale={[scale, scale, scale]}\n      />\n    </RigidBody>\n  );\n};\n\nexport default OverflowEmoji3D; ","/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/OverflowEmojiManager.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/components/mood-tracker/v5/PhysicsGround.jsx",[],[],"/Users/ihyeonji/Desktop/cd3/Final4/Friend/pages/mood-tracker-alt.js",["390","391","392","393"],[],"import { Suspense, useState, useRef } from 'react';\nimport { Canvas, useThree } from '@react-three/fiber';\nimport { OrbitControls, useGLTF, Environment, Html } from '@react-three/drei';\nimport { a, useSpring } from '@react-spring/three';\nimport * as THREE from 'three';\nimport Scale from '../components/Scale';\n\n// --- Configuration ---\n// IMPORTANT: Adjust this Y-offset based on your Body.gltf's height and desired pivot point\nconst BODY_PIVOT_Y_OFFSET = 1.5;\nconst TILT_ANGLE = Math.PI / 12; // Approx 15 degrees tilt\n\n// --- GLTF Model Loaders ---\nfunction BodyModel(props) {\n  const { scene } = useGLTF('/Body.gltf');\n  return <primitive object={scene} {...props} />;\n}\n\nfunction WingsModel({ onPlateClick, ...props }) {\n  const { scene } = useGLTF('/Wings.gltf');\n  // The entire Wings.gltf model will be clickable.\n  // We determine which side was clicked based on the click position relative to the model's center.\n  return (\n    <primitive\n      object={scene}\n      onPointerDown={(event) => {\n        event.stopPropagation();\n        // Assuming event.object is a mesh within Wings.gltf\n        // Convert the world click point to the local coordinate system of the clicked mesh\n        const localPoint = event.object.worldToLocal(event.point.clone());\n        \n        // Determine if the click was on the \"left\" or \"right\" side\n        // based on the local x-coordinate, assuming the wings spread along the x-axis\n        // and the model's origin is at its center.\n        const isLeftSideClicked = localPoint.x < 0;\n        onPlateClick(isLeftSideClicked ? 'left' : 'right');\n      }}\n      {...props}\n    />\n  );\n}\n\n// 간단한 스타일 컴포넌트\nconst FullScreenContainer = ({ children }) => (\n  <div style={{\n    width: '100vw',\n    height: '100vh',\n    display: 'flex',\n    flexDirection: 'column',\n    justifyContent: 'center',\n    alignItems: 'center',\n    background: '#ffffff',\n    overflow: 'hidden',\n    position: 'relative'\n  }}>\n    {children}\n  </div>\n);\n\nconst IconBarPlaceholder = ({ onSelectIcon }) => {\n  const emojis = ['😀', '😮', '😐', '😖', '😠']; \n  return (\n    <div style={{\n      position: 'absolute',\n      bottom: '7vh',\n      display: 'flex',\n      gap: '30px', \n    }}>\n      {emojis.map((emoji, index) => (\n        <div key={index} style={{\n          fontSize: '130px', // 스타일 유지\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          cursor: 'pointer',\n        }} onClick={() => onSelectIcon(emoji)}>\n          {emoji}\n        </div>\n      ))}\n    </div>\n  );\n};\n\n// 저울에 이모티콘을 올리기 위한 상태 관리\nfunction ScaledScene({ \n  selectedIcon,\n  bodyProps,\n  wingsProps,\n  wingsPrimitiveOffset,\n  tiltAngle,\n  verticalMovementFactor\n}) {\n  const [iconsOnScale, setIconsOnScale] = useState([]);\n  const { viewport, size } = useThree();\n  const aspect = size.width / size.height;\n  let scaleFactor;\n\n  if (aspect > 1) {\n    scaleFactor = viewport.height / 5.0;\n  } else {\n    scaleFactor = viewport.height / 6.0;\n  }\n\n  const handleIconDrop = (event) => {\n    if (selectedIcon) {\n      const newIconData = {\n        emoji: selectedIcon,\n        position: [-0.5 - iconsOnScale.length * 0.3, 0.2, 0] \n      };\n      setIconsOnScale(prevState => [...prevState, newIconData]);\n    }\n  };\n\n  return (\n    <group scale={[scaleFactor, scaleFactor, scaleFactor]} rotation={[-Math.PI / 12, 0, 0]} onPointerDown={handleIconDrop}>\n      <Scale \n        bodyProps={bodyProps}\n        wingsProps={wingsProps}\n        wingsPrimitiveOffset={wingsPrimitiveOffset}\n        tiltAngle={tiltAngle}\n        verticalMovementFactor={verticalMovementFactor}\n      />\n      {iconsOnScale.map((iconData, index) => (\n        <Html key={index} position={iconData.position} transform>\n          <div style={{ fontSize: '30px', userSelect: 'none' }}> \n            {iconData.emoji}\n          </div>\n        </Html>\n      ))}\n    </group>\n  );\n}\n\nexport default function MoodTrackerPage() {\n  const [selectedIcon, setSelectedIcon] = useState(null);\n\n  // Props for the Scale component, derived from mood-tracker.jsx\n  const bodyProps = { position: [0, 0.5, 0], scale: 1.9 };\n  const wingsProps = { position: [0, -0.02, 0], scale: 1.1 }; \n  const wingsPrimitiveOffset = [0, 0, 0];\n  const tiltAngle = Math.PI / 20;\n  const verticalMovementFactor = 0.03;\n\n  return (\n    <FullScreenContainer>\n      <div style={{ width: '90%', height: '90%', maxWidth: '1200px', maxHeight: '900px', position: 'relative' }}> {/* 스타일 유지 */}\n        <Canvas camera={{ position: [0, 3.5, 7], fov: 50 }}> {/* 설정 유지 */}\n          <Suspense fallback={null}>\n            <ambientLight intensity={0.25} color=\"#FFFFFF\" /> {/* 설정 유지 */}\n            <directionalLight position={[8, 10, 5]} intensity={0.2} castShadow shadow-mapSize-width={1024} shadow-mapSize-height={1024}/> {/* 설정 유지 */}\n            <directionalLight position={[-8, 5, -8]} intensity={0.1} color=\"#E3F2FD\" /> {/* 설정 유지 */}\n            <Environment preset=\"sunset\" intensity={0.8} blur={0.5} /> {/* 설정 유지 */}\n            <ScaledScene \n              selectedIcon={selectedIcon} \n              bodyProps={bodyProps}\n              wingsProps={wingsProps}\n              wingsPrimitiveOffset={wingsPrimitiveOffset}\n              tiltAngle={tiltAngle}\n              verticalMovementFactor={verticalMovementFactor}\n            />\n            <OrbitControls /> {/* 설정 유지 */}\n          </Suspense>\n        </Canvas>\n      </div>\n      <IconBarPlaceholder onSelectIcon={setSelectedIcon} />\n    </FullScreenContainer>\n  );\n}\n\n// Preload GLTF files for better performance\nuseGLTF.preload('/Body.gltf');\nuseGLTF.preload('/Wings.gltf'); ",{"ruleId":"394","severity":1,"message":"395","line":3,"column":43,"nodeType":"396","messageId":"397","endLine":3,"endColumn":50},{"ruleId":"394","severity":1,"message":"398","line":47,"column":38,"nodeType":"396","messageId":"397","endLine":47,"endColumn":45},{"ruleId":"394","severity":1,"message":"399","line":299,"column":25,"nodeType":"396","messageId":"397","endLine":299,"endColumn":31},{"ruleId":"394","severity":1,"message":"398","line":299,"column":33,"nodeType":"396","messageId":"397","endLine":299,"endColumn":40},{"ruleId":"394","severity":1,"message":"400","line":487,"column":32,"nodeType":"396","messageId":"397","endLine":487,"endColumn":37},{"ruleId":"394","severity":1,"message":"401","line":487,"column":39,"nodeType":"396","messageId":"397","endLine":487,"endColumn":47},{"ruleId":"394","severity":1,"message":"402","line":537,"column":9,"nodeType":"396","messageId":"397","endLine":537,"endColumn":17},{"ruleId":"394","severity":1,"message":"403","line":8,"column":7,"nodeType":"396","messageId":"397","endLine":8,"endColumn":20},{"ruleId":"394","severity":1,"message":"404","line":658,"column":9,"nodeType":"396","messageId":"397","endLine":658,"endColumn":15},{"ruleId":"394","severity":1,"message":"405","line":697,"column":11,"nodeType":"396","messageId":"397","endLine":697,"endColumn":24},{"ruleId":"394","severity":1,"message":"406","line":5,"column":25,"nodeType":"396","messageId":"397","endLine":5,"endColumn":34},{"ruleId":"394","severity":1,"message":"407","line":5,"column":17,"nodeType":"396","messageId":"397","endLine":5,"endColumn":23},{"ruleId":"394","severity":1,"message":"408","line":8,"column":10,"nodeType":"396","messageId":"397","endLine":8,"endColumn":18},{"ruleId":"394","severity":1,"message":"409","line":19,"column":3,"nodeType":"396","messageId":"397","endLine":19,"endColumn":16},{"ruleId":"394","severity":1,"message":"410","line":20,"column":3,"nodeType":"396","messageId":"397","endLine":20,"endColumn":17},{"ruleId":"394","severity":1,"message":"411","line":21,"column":3,"nodeType":"396","messageId":"397","endLine":21,"endColumn":21},{"ruleId":"394","severity":1,"message":"412","line":22,"column":3,"nodeType":"396","messageId":"397","endLine":22,"endColumn":22},{"ruleId":"394","severity":1,"message":"413","line":23,"column":3,"nodeType":"396","messageId":"397","endLine":23,"endColumn":29},{"ruleId":"394","severity":1,"message":"414","line":24,"column":3,"nodeType":"396","messageId":"397","endLine":24,"endColumn":30},{"ruleId":"394","severity":1,"message":"415","line":30,"column":10,"nodeType":"396","messageId":"397","endLine":30,"endColumn":23},{"ruleId":"394","severity":1,"message":"416","line":30,"column":25,"nodeType":"396","messageId":"397","endLine":30,"endColumn":41},{"ruleId":"394","severity":1,"message":"417","line":31,"column":10,"nodeType":"396","messageId":"397","endLine":31,"endColumn":24},{"ruleId":"394","severity":1,"message":"418","line":31,"column":26,"nodeType":"396","messageId":"397","endLine":31,"endColumn":43},{"ruleId":"394","severity":1,"message":"419","line":24,"column":27,"nodeType":"396","messageId":"397","endLine":24,"endColumn":33},{"ruleId":"394","severity":1,"message":"420","line":25,"column":9,"nodeType":"396","messageId":"397","endLine":25,"endColumn":15},{"ruleId":"394","severity":1,"message":"421","line":27,"column":55,"nodeType":"396","messageId":"397","endLine":27,"endColumn":60},{"ruleId":"394","severity":1,"message":"422","line":3,"column":73,"nodeType":"396","messageId":"397","endLine":3,"endColumn":87},{"ruleId":"394","severity":1,"message":"423","line":1,"column":35,"nodeType":"396","messageId":"397","endLine":1,"endColumn":42},{"ruleId":"394","severity":1,"message":"424","line":2,"column":10,"nodeType":"396","messageId":"397","endLine":2,"endColumn":23},{"ruleId":"394","severity":1,"message":"422","line":3,"column":73,"nodeType":"396","messageId":"397","endLine":3,"endColumn":87},{"ruleId":"394","severity":1,"message":"423","line":1,"column":35,"nodeType":"396","messageId":"397","endLine":1,"endColumn":42},{"ruleId":"394","severity":1,"message":"424","line":2,"column":10,"nodeType":"396","messageId":"397","endLine":2,"endColumn":23},{"ruleId":"394","severity":1,"message":"420","line":25,"column":9,"nodeType":"396","messageId":"397","endLine":25,"endColumn":15},{"ruleId":"394","severity":1,"message":"425","line":50,"column":13,"nodeType":"396","messageId":"397","endLine":50,"endColumn":24},{"ruleId":"394","severity":1,"message":"426","line":60,"column":13,"nodeType":"396","messageId":"397","endLine":60,"endColumn":19},{"ruleId":"394","severity":1,"message":"427","line":72,"column":13,"nodeType":"396","messageId":"397","endLine":72,"endColumn":20},{"ruleId":"394","severity":1,"message":"428","line":73,"column":13,"nodeType":"396","messageId":"397","endLine":73,"endColumn":20},{"ruleId":"394","severity":1,"message":"422","line":3,"column":73,"nodeType":"396","messageId":"397","endLine":3,"endColumn":87},{"ruleId":"394","severity":1,"message":"423","line":1,"column":35,"nodeType":"396","messageId":"397","endLine":1,"endColumn":42},{"ruleId":"394","severity":1,"message":"424","line":2,"column":10,"nodeType":"396","messageId":"397","endLine":2,"endColumn":23},{"ruleId":"394","severity":1,"message":"429","line":45,"column":13,"nodeType":"396","messageId":"397","endLine":45,"endColumn":22},{"ruleId":"394","severity":1,"message":"430","line":45,"column":32,"nodeType":"396","messageId":"397","endLine":45,"endColumn":40},{"ruleId":"394","severity":1,"message":"431","line":68,"column":13,"nodeType":"396","messageId":"397","endLine":68,"endColumn":22},{"ruleId":"432","severity":1,"message":"433","line":91,"column":6,"nodeType":"434","endLine":91,"endColumn":97,"suggestions":"435"},{"ruleId":"432","severity":1,"message":"436","line":121,"column":6,"nodeType":"434","endLine":121,"endColumn":100,"suggestions":"437"},{"ruleId":"394","severity":1,"message":"423","line":1,"column":35,"nodeType":"396","messageId":"397","endLine":1,"endColumn":42},{"ruleId":"394","severity":1,"message":"423","line":1,"column":35,"nodeType":"396","messageId":"397","endLine":1,"endColumn":42},{"ruleId":"394","severity":1,"message":"424","line":2,"column":10,"nodeType":"396","messageId":"397","endLine":2,"endColumn":23},{"ruleId":"394","severity":1,"message":"438","line":5,"column":37,"nodeType":"396","messageId":"397","endLine":5,"endColumn":44},{"ruleId":"394","severity":1,"message":"398","line":49,"column":38,"nodeType":"396","messageId":"397","endLine":49,"endColumn":45},{"ruleId":"394","severity":1,"message":"398","line":537,"column":33,"nodeType":"396","messageId":"397","endLine":537,"endColumn":40},{"ruleId":"394","severity":1,"message":"439","line":788,"column":19,"nodeType":"396","messageId":"397","endLine":788,"endColumn":28},{"ruleId":"394","severity":1,"message":"400","line":1213,"column":32,"nodeType":"396","messageId":"397","endLine":1213,"endColumn":37},{"ruleId":"394","severity":1,"message":"401","line":1213,"column":39,"nodeType":"396","messageId":"397","endLine":1213,"endColumn":47},{"ruleId":"394","severity":1,"message":"402","line":1315,"column":9,"nodeType":"396","messageId":"397","endLine":1315,"endColumn":17},{"ruleId":"394","severity":1,"message":"440","line":1412,"column":9,"nodeType":"396","messageId":"397","endLine":1412,"endColumn":27},{"ruleId":"394","severity":1,"message":"441","line":8,"column":3,"nodeType":"396","messageId":"397","endLine":8,"endColumn":13},{"ruleId":"394","severity":1,"message":"442","line":11,"column":3,"nodeType":"396","messageId":"397","endLine":11,"endColumn":15},{"ruleId":"394","severity":1,"message":"443","line":19,"column":3,"nodeType":"396","messageId":"397","endLine":19,"endColumn":17},{"ruleId":"432","severity":1,"message":"444","line":88,"column":6,"nodeType":"434","endLine":88,"endColumn":100,"suggestions":"445"},{"ruleId":"432","severity":1,"message":"444","line":144,"column":6,"nodeType":"434","endLine":144,"endColumn":103,"suggestions":"446"},{"ruleId":"394","severity":1,"message":"408","line":2,"column":10,"nodeType":"396","messageId":"397","endLine":2,"endColumn":18},{"ruleId":"394","severity":1,"message":"441","line":6,"column":62,"nodeType":"396","messageId":"397","endLine":6,"endColumn":72},{"ruleId":"394","severity":1,"message":"407","line":1,"column":30,"nodeType":"396","messageId":"397","endLine":1,"endColumn":36},{"ruleId":"394","severity":1,"message":"447","line":4,"column":10,"nodeType":"396","messageId":"397","endLine":4,"endColumn":11},{"ruleId":"394","severity":1,"message":"448","line":4,"column":13,"nodeType":"396","messageId":"397","endLine":4,"endColumn":22},{"ruleId":"394","severity":1,"message":"421","line":104,"column":27,"nodeType":"396","messageId":"397","endLine":104,"endColumn":32},"no-unused-vars","'useGLTF' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","Identifier","unusedVar","'keyword' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'onBack' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'emoji' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'keywords' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'keywords' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'emojiKeywords' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'router' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'dominantEmoji' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'useEffect' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'useRef' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'useFrame' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'tiltAngleLeft' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'tiltAngleRight' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'animationSpeedLeft' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'animationSpeedRight' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'verticalMovementFactorLeft' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'verticalMovementFactorRight' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'isHoveredLeft' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'setIsHoveredLeft' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'isHoveredRight' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'setIsHoveredRight' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'camera' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'aspect' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'event' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'onSliderChange' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'useMemo' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'emojiKeywords' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'newWorldPos' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'factor' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'worldDx' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'worldDy' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'emojiType' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'position' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'newEmojis' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'leftEmojis.length'. Either include it or remove the dependency array.","ArrayExpression",["449"],"React Hook useEffect has a missing dependency: 'rightEmojis.length'. Either include it or remove the dependency array.",["450"],"'onClose' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'shapeInfo' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'getCurrentDateTime' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'basketSide' is defined but never used. Allowed unused args must match /^(_|unused)/u.","'emojiSpacing' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'zPositionRange' is assigned a value but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","React Hook useMemo has a missing dependency: 'USABLE_RADIUS'. Either include it or remove the dependency array.",["451"],["452"],"'a' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.","'useSpring' is defined but never used. Allowed unused vars must match /^(_|[A-Z_])/u.",{"desc":"453","fix":"454"},{"desc":"455","fix":"456"},{"desc":"457","fix":"458"},{"desc":"459","fix":"460"},"Update the dependencies array to be: [leftCount, leftEmojiTypes, leftBasketX, dropHeight, randomXRange, randomZRange, dropDelay, leftEmojis.length]",{"range":"461","text":"462"},"Update the dependencies array to be: [rightCount, rightEmojiTypes, rightBasketX, dropHeight, randomXRange, randomZRange, dropDelay, rightEmojis.length]",{"range":"463","text":"464"},"Update the dependencies array to be: [leftBasketCount, leftEmojiTypes, USABLE_RADIUS, randomnessRange, leftBasketX, zPositionOffset, basketHeight]",{"range":"465","text":"466"},"Update the dependencies array to be: [rightBasketCount, rightEmojiTypes, USABLE_RADIUS, randomnessRange, rightBasketX, zPositionOffset, basketHeight]",{"range":"467","text":"468"},[3007,3098],"[leftCount, leftEmojiTypes, leftBasketX, dropHeight, randomXRange, randomZRange, dropDelay, leftEmojis.length]",[4157,4251],"[rightCount, rightEmojiTypes, rightBasketX, dropHeight, randomXRange, randomZRange, dropDelay, rightEmojis.length]",[3036,3130],"[leftBasketCount, leftEmojiTypes, USABLE_RADIUS, randomnessRange, leftBasketX, zPositionOffset, basketHeight]",[5168,5265],"[rightBasketCount, rightEmojiTypes, USABLE_RADIUS, randomnessRange, rightBasketX, zPositionOffset, basketHeight]"]